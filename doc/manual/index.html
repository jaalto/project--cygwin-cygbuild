<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>cygbuild - Cygwin source and binary package build script</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:Yaakov@yaakov04.nonet" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#packages_with_no_version_number">Packages with no version number</a></li>
		<li><a href="#packaging_directly_from_version_control_repositories">Packaging directly from version control repositories</a></li>
	</ul>

	<li><a href="#a_quick_overview">A QUICK OVERVIEW</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></li>
	<ul>

		<li><a href="#preparation_commands">Preparation commands</a></li>
		<li><a href="#build_commands">Build commands</a></li>
		<li><a href="#install_commands__in_order_of_execution_">Install commands (in order of execution)</a></li>
		<li><a href="#packaging_commands">Packaging commands</a></li>
		<li><a href="#digital_signature_commands">Digital signature commands</a></li>
		<li><a href="#patch_management_commands">Patch management commands</a></li>
		<li><a href="#other_commands">Other commands</a></li>
	</ul>

	<li><a href="#making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></li>
	<ul>

		<li><a href="#preliminary_setup">Preliminary setup</a></li>
		<li><a href="#now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></li>
		<li><a href="#contributing_packages">Contributing packages</a></li>
	</ul>

	<li><a href="#gpg_examples">GPG EXAMPLES</a></li>
	<li><a href="#optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></li>
	<ul>

		<li><a href="#bin__directory">bin/ directory</a></li>
		<li><a href="#man__directory">man/ directory</a></li>
		<li><a href="#patches__directory">patches/ directory</a></li>
	</ul>

	<li><a href="#optional_external_files">OPTIONAL EXTERNAL FILES</a></li>
	<li><a href="#managing_a_build_tree">MANAGING A BUILD TREE</a></li>
	<ul>

		<li><a href="#how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></li>
		<li><a href="#rebuilding_packages">Rebuilding packages</a></li>
	</ul>

	<li><a href="#library_usage">LIBRARY USAGE</a></li>
	<li><a href="#cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></li>
	<ul>

		<li><a href="#using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></li>
		<li><a href="#music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></li>
	</ul>

	<li><a href="#troubleshooting">TROUBLESHOOTING</a></li>
	<ul>

		<li><a href="#porting_and_python_os_rename">Porting and Python os.rename</a></li>
		<li><a href="#general_errors">General errors</a></li>
		<li><a href="#problem_with_command__all_">Problem with command [all]</a></li>
		<li><a href="#command__check__cannot_find_files">Command [check] cannot find files</a></li>
		<li><a href="#problem_with_command__install_">Problem with command [install]</a></li>
		<li><a href="#command__package__displays_warnings">Command [package] displays warnings</a></li>
		<li><a href="#while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></li>
	</ul>

	<li><a href="#environment">ENVIRONMENT</a></li>
	<li><a href="#files">FILES</a></li>
	<li><a href="#standards">STANDARDS</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<ul>

		<li><a href="#commands_must_be_ordered">Commands must be ordered</a></li>
		<li><a href="#other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></li>
		<li><a href="#reporting_bugs">Reporting bugs</a></li>
		<li><a href="#slow_program_startup">Slow program startup</a></li>
	</ul>

	<li><a href="#miscellaneous">MISCELLANEOUS</a></li>
	<ul>

		<li><a href="#makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></li>
		<li><a href="#yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></li>
		<li><a href="#cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></li>
		<li><a href="#use_of_hard_links">Use of hard links</a></li>
		<li><a href="#setup_hint_should_list_all_dependencies">setup.hint should list all dependencies</a></li>
	</ul>

	<li><a href="#availability">AVAILABILITY</a></li>
	<li><a href="#osnames">OSNAMES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>cygbuild - Cygwin source and binary package build script</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    cygbuild [options] [-r RELEASE] CMD [CMD ...]</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This program builds Cygwin binary and source packages. Refer to <em>Cygwin
Package Contributor's Guide</em> at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for more
information about the details of packaging phase. Due to complex nature of
various source packages out there, it is impossible to completely automate
the packaging steps. Some manual work will always be needed. The hairy
ports are those that have very vague and misbehaving <code>Makefile</code> which
install files to all over the system and distribute copies of files with
<code>cp(1)</code> instead of <a href="#install"><code>install(1)</code></a>. Ahem, you as &quot;the porter&quot;, know the
drill and have to use your hands to <code>Makefile</code> mud tar pit. Solid
<code>Makefile</code> experience is therefore a requirement before thinking to port
any packages to Cygwin.</p>
<p>If <code>gpg(1)</code> is installed, the patch, binary and source package can be
cryptographically signed. See options <strong>--sign</strong> and <strong>--passphrase</strong>.</p>
<p>
</p>
<h2><a name="packages_with_no_version_number">Packages with no version number</a></h2>
<p>To port a package which does not have a version number, one has to be
generated out of the blue. Program relies on the fact that the VERSION
number is included in the original package name and in the unpack
directory. The package extensions can be <code>*.tar.gz</code>, <code>*.tar.bz2</code>
<code>*.tar.xz</code> or <code>*.tgz</code>. The recognized package file name formats
include:</p>
<pre>
    package-N[.N]+.tar.gz                Universal packaging format
    package_N[.N]+.orig.tar.gz           Debian source packages</pre>
<p>Examples:</p>
<pre>
    package-1.2.tar.gz
    package-0.0.2.tar.bz2
    package-12.0.2.1.tgz</pre>
<p>The package name can consist of many words separated by hyphens:</p>
<pre>
    package-name-long-N[.N]+.tar.gz         hyphens
    package_name_invalid-N[.N]+.tar.gz      Underscores not allowed</pre>
<p>In case file uses some other naming or numbering scheme, it's a
problem. Similarly if the unpack directory structure does not use
universal format <code>package-N.N</code>, it's a problem. Suppose a package
unpacks like this:</p>
<pre>
    tar -zxvf package-beta-latest.tar.gz
        ...
        package-latest
        package-latest/src
        package-latest/doc</pre>
<p>The situation can be coped by making a symbolic link to whatever is
appropriate for the version number. If unsure, pick a YYYYMMDD in case
there is no relevant version that can be used for the package.</p>
<pre>
    ln -s package-beta-latest.tar.gz package-YYYYMMDD.tar.gz
    ln -s package-latest/ package-YYYYMMDD/</pre>
<p>It is important that you do all your work inside the directory with VERSION
number, not in directory <code>package-latest/</code>.</p>
<pre>
    cd package-YYYYMMDD/
    ... now proceed with the porting</pre>
<p>
</p>
<h2><a name="packaging_directly_from_version_control_repositories">Packaging directly from version control repositories</a></h2>
<p>It is easy to make build snapshots by using symlinks with time based
version numbers, like <code>package-20010123</code>, which effectively means
YYYYMMDD. To make a release, it could be done like this:</p>
<pre>
    cvs -d :pserver:&lt;remote&gt; co foopackage
    date=$(date &quot;+%Y%M%d&quot;)
    ln -s foopackage foopackage-$date
    cd foopackage-$date
    ... proceed to package this snapshot
    cygbuild -r 1 mkdirs files conf make install package source-package</pre>
<p>
</p>
<hr />
<h1><a name="a_quick_overview">A QUICK OVERVIEW</a></h1>
<p>The directories used in the program are as follows:</p>
<pre>
  ROOT/package
       &lt;original upstream package source(s): package-1.2.3.tar.gz&gt;
       |
       +- package-1.2.3/
          &lt;upstream *.tar.gz unpacked&gt;
          &lt;All cygbuild commands must be given in *this* directory&gt;
          |
          +- .build/
          |  &lt;generic working area of temporary files&gt;
          |  |
          |  +- build/
          |  |  &lt;separate &quot;shadow&quot; directory where compiling happens&gt;
          |  |  &lt;contains only symlinks and object *.o etc. files&gt;
          |  |
          |  +- package-1.2.3/
          |  |  &lt;Used during taking a diff for Cygwin source package&gt;
          |  |  &lt;&quot;make clean&quot;, unpatches sources; copy of ROOT/package-1.2.3&gt;
          |  |
          |  +- package-1.2.3-orig/
          |     &lt;Used during taking a diff for Cygwin source package&gt;
          |
          +- .inst/
          |  &lt;The &quot;make install&quot; target directory&gt;
          |
          +- .sinst/
              &lt;diffs, signatures, binary and source packages appear here&gt;</pre>
<p><strong>CASE A)</strong> to build Cygwin Net Release from a package that includes a
standard <a href="#configure"><code>./configure</code></a> script, the quick path for porting would be in
the fortunate case:</p>
<pre>
    export NAME=&quot;Firstname Lastname&quot;   # An example in Bash syntax
    export EMAIL=&quot;foo@example.com&quot;</pre>
<pre>
    ... make a project directory</pre>
<pre>
    mkdir -p /tmp/package
    cd /tmp/package
    wget <a href="http://example.com/package-N.N.tar.gz">http://example.com/package-N.N.tar.gz</a>
    tar -zxvf package-N.N.tar.gz</pre>
<pre>
    ... source has now been unpacked, go there</pre>
<pre>
    cd package-N.N/</pre>
<pre>
    ... If this is the first port ever, it is better to run commands
    ... individually to see possible problems.
    ...
    ... If you have GPG key, you can add options -s &quot;SignerKeyID&quot;
    ... -p &quot;pass phrase&quot; to commands 'package', 'source-package' and
    ... 'publish'. Option -r marks &quot;release 1&quot;.</pre>
<pre>
    cygbuild -r 1 makedirs
    cygbuild -r 1 files
    cygbuild -r 1 readmefix       # Fill in CYGWIN/package.README
    cygbuild -r 1 shadow          # prepare sources to .build/build
    cygbuild -r 1 configure
    cygbuild -r 1 make
    cygbuild -r 1 -v -t install   # &quot;verbose test mode&quot; first
    cygbuild -r 1 install         # The &quot;real&quot; install</pre>
<pre>
    find .inst/ -print            # Verify install structure</pre>
<pre>
    cygbuild -r 1 -v check        # Do install integrity check
    cygbuild -r 1 package         # Make Net install binary
    cygbuild -r 1 source-package  # Make Net install source
    cygbuild -r 1 publish         # Copy files to publish area (if any)</pre>
<p>To make this easier, an alias (example in Bash) will help.</p>
<pre>
    alias cb=&quot;cygbuild --color --sign $GPGKEY --release&quot;
    cb 1 import
    ...</pre>
<p><strong>CASE B)</strong> If the downloaded Cygwin source release package is
controlled by cygbuild, then commands <strong>[all]</strong> and <strong>[almostall]</strong> can
be used to check the binary build:</p>
<pre>
    mkdir -p /tmp/package
    cd /tmp/package
    tar -xf /path/to/package-N.N-RELEASE-src.tar.xz
    ./*.sh --color --verbose all</pre>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<dl>
<dt><strong><a name="b_bzip2" class="item"><strong>-b, --bzip2</strong></a></strong></dt>

<dd>
<p>Use bzip2 compression instead of default package compression. This
affects the manual pages and the usr/share/doc/*/ content.</p>
</dd>
<dt><strong><a name="c_color" class="item"><strong>-c, --color</strong></a></strong></dt>

<dd>
<p>Activate colors in displayed messages.</p>
</dd>
<dt><strong><a name="cygbuiddir_dir" class="item"><strong>--cygbuiddir DIR</strong></a></strong></dt>

<dd>
<p>PATH where all the temporary files are kept; object files, taking diffs
etc. The default value is <a href="#build"><code>./.build</code></a>.</p>
</dd>
<dt><strong><a name="cyginstdir_dir" class="item"><strong>--cyginstdir DIR</strong></a></strong></dt>

<dd>
<p>PATH where <code>make install</code> will install the source package's executable
files, documentation files etc. The default value is <code>./.inst</code>.</p>
</dd>
<dt><strong><a name="cygsinstdir_dir" class="item"><strong>--cygsinstdir DIR</strong></a></strong></dt>

<dd>
<p>PATH where ready Cygwin Net Release packages and patch files are put.
etc. The default value is <code>./.sinst</code>.</p>
</dd>
<dt><strong><a name="d_debug_level" class="item"><strong>-d, --debug LEVEL</strong></a></strong></dt>

<dd>
<p>Turn on debug. Usually means running external shell files with -x
enabled.</p>
</dd>
<dt><strong><a name="e_email_email" class="item"><strong>-e, --email EMAIL</strong></a></strong></dt>

<dd>
<p>Set email address. This effectively sets variable <code>CYGBUILD_EMAIL</code>
that is used in <strong>[readmefix]</strong> command.</p>
</dd>
<dt><strong><a name="g_gbs" class="item"><strong>-g, --gbs</strong></a></strong></dt>

<dd>
<p>Activate g-b-s compatibility mode -- that is -- behave like Cygwin Build
Script. This changes behavior and command in the following manner:</p>
<dl>
<dt><strong><a name="commands_all_binary_package_and_source_package" class="item">commands: <strong>[all]</strong>, <strong>[binary-package]</strong> and <strong>[source-package]</strong></a></strong></dt>

<dd>
<p>Move the generated source package <code>package-N.N.tar.xz</code> and binary package
<code>package-N.N-src.tar.xz</code> to one directory up <code>../</code> instead the default
location &lt;./sinst&gt;.</p>
</dd>
</dl>
</dd>
<dt><strong><a name="f_file_file" class="item"><strong>-f, --file FILE</strong></a></strong></dt>

<dd>
<p>Specify package file and version, like <code>package-1.11.tar.gz</code> from which the
VERSION and possible RELEASE numbers can be derived. This option is needed
only if the current directory is not in format <code>package-version</code>. Problems
in 99% of the cases are in the source file names. See 'Packages with
non-standard versioning schemes' how to deal with unusual packages when
doing porting.</p>
<p>This option comes handy with command <strong>[check]</strong> when someone else's
binary package results are being checked. An example:</p>
<pre>
  ls
    ...
    package-2.1.tar.gz
    package-2.1-1.tar.xz
    package-2.1-1-src.tar.xz</pre>
<pre>
  .. make a &quot;pseudo&quot; install directory</pre>
<pre>
  mkdir .inst</pre>
<pre>
  .. examine the binary package</pre>
<pre>
  (cd .inst ; tar -jxvf ../package-2.1-1.tar.xz)
  cygbuild -f package-2.1-1.tar.xz --cyginstdir .inst --verbose check</pre>
</dd>
<dt><strong><a name="install_prefix_prefix" class="item"><strong>--install-prefix PREFIX</strong></a></strong></dt>

<dd>
<p>Set custom install PREFIX. The value must be path (no leading slash)
relative to install dir <code>./.sinst</code>. The default is to install using prefix
value <em>usr</em>, which puts files in directories like:</p>
<pre>
    usr/bin
    usr/share/doc
    ...</pre>
</dd>
<dt><strong><a name="install_usrlocal" class="item"><strong>--install-usrlocal</strong></a></strong></dt>

<dd>
<p>Arrange all relevant prefixes to use <code>usr/local</code> install structure instead
of the default <code>usr</code>. With this option the packages created are suitable
for private installation. Keep this option with every command, so that
program knows about the special port:</p>
<pre>
    cygbuild --release 1 --install-usrlocal CMD ...</pre>
</dd>
<dt><strong><a name="l_lzma" class="item"><strong>-l, --lzma</strong></a></strong></dt>

<dd>
<p>Use lzma compression instead of default package compression. This
affects also the usr/share/doc/*/ content.</p>
</dd>
<dt><strong><a name="p_passphrase_pass_phrase" class="item"><strong>-p, --passphrase &quot;PASS PHRASE&quot;</strong></a></strong></dt>

<dd>
<p>Signing pass phrase. In multiuser environment, consider security carefully
before using this option.</p>
</dd>
<dt><strong><a name="r_release_release" class="item"><strong>-r, --release RELEASE</strong></a></strong></dt>

<dd>
<p>This option is required option by almost all commands.</p>
<p>Specify build release: 1, 2, 3 etc. If this is word &quot;date&quot;, then derive
build number from <code>date(1)</code> in format YYYYMMDDHHMM</p>
</dd>
<dt><strong><a name="s_sign_signkey" class="item"><strong>-s, --sign SIGNKEY</strong></a></strong></dt>

<dd>
<p>GPG key to use for signing. It is best to use the hexadecimal unique key
id to avoid picking the wrong key from key ring. See <code>gpg --list-keys</code>.</p>
</dd>
<dt><strong><a name="t_test" class="item"><strong>-t, --test</strong></a></strong></dt>

<dd>
<p>Run in test mode. This option is respected when <strong>[install]</strong> command is
run: no actual changes or install is done. This is good way to check that
Makefile doesn't mistakenly install to system directories.</p>
</dd>
<dt><strong><a name="v_verbose" class="item"><strong>-v, --verbose</strong></a></strong></dt>

<dd>
<p>Print more informational messages.</p>
</dd>
<dt><strong><a name="x_no_strip" class="item"><strong>-x, --no-strip</strong></a></strong></dt>

<dd>
<p>Do not strip executables or check strip status before command <strong>[package]</strong>.
Use this option if package contains only interpreted files like Perl,
Python or Shell scripts etc.</p>
<p><strong>NOTE:</strong> This options should be avoided and it may be removed. Program is
99% in the cases able to detect if and when strip is needed.</p>
</dd>
<dt><strong><a name="xz" class="item"><strong>--xz</strong></a></strong></dt>

<dd>
<p>Use xz compression instead of default package compression. This
affects also the usr/share/doc/*/ content.</p>
</dd>
<dt><strong><a name="h" class="item"><strong>-h</strong></a></strong></dt>

<dd>
<p>Print program's internal short help.</p>
</dd>
<dt><strong><a name="help" class="item"><strong>--help</strong></a></strong></dt>

<dd>
<p>Print long help (this page).</p>
</dd>
<dt><strong><a name="v_version_version" class="item"><strong>-V, --version|--Version</strong></a></strong></dt>

<dd>
<p>Print version number.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></h1>
<p>
</p>
<h2><a name="preparation_commands">Preparation commands</a></h2>
<dl>
<dt><strong><a name="mkdirs_dirs" class="item"><strong>mkdirs, dirs</strong></a></strong></dt>

<dd>
<p>Make Cygwin build directories</p>
<pre>
    package-N.N/.build/                    Scratch work area
    package-N.N/.inst/                     Binary package
    package-N.N/.sinst/                    Source package
    package-N.N/CYGWIN-PATCHES/            Control directory</pre>
</dd>
<dt><strong><a name="files" class="item"><strong>files</strong></a></strong></dt>

<dd>
<p>Install default files into <code>package-N.N/CYGWIN-PATCHES/</code>. You have to edit
two mandatory files, <code>README</code> and <code>setup.hint</code>, before running building a
binary package with command <strong>[package]</strong>. Files that include extension
<code>.ex</code> are examples. These files are only needed if package cannot be
ported directly by using standard <a href="#configure"><code>./configure</code></a> or <code>make install</code> calls.</p>
<pre>
    package.README          Mandatory, edit this
    setup.hint              Mandatory, edit this
    conf.sh.ex              optional; If there is no ./configure
    build.sh.ex             optional; If standard &quot;make all&quot;
                                      doesn't do it
    install.sh.ex           optional; If &quot;make install&quot;
                                      doesn't do it
    install-after.sh.ex     optional; If &quot;make install&quot;
                                      quite didn't do it right. E.g
                                      moving .inst/etc/* files elsewhere
    postinstall.sh.ex       optional; Things to do after system
                                      install for binary packages</pre>
<p>If you remove the extension <code>.ex</code>, the shell scripts are automatically
noticed and used. You can leave the files alone if you do not use them,
because all files ending to <code>.ex</code> are ignored during
packaging commands <strong>[package]</strong> or <strong>[source-package]</strong>.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="build_commands">Build commands</a></h2>
<dl>
<dt><strong><a name="configure" class="item"><strong>configure</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/configure.sh</code>. If not found,
try <code>package-N.N/configure</code> or <code>package-N.N/buildconf</code> with
predefined Cygwin switches</p>
<p>Before this command, the source files should have been prepared with
command <strong>[shadow]</strong> (which see).</p>
</dd>
<dt><strong><a name="build" class="item"><strong>build</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/build.sh</code>. If not found, then
run command which resembles something like below (cf. <strong>ENVIRONMENT</strong>):</p>
<pre>
    LDFLAGS= CFLAGS=&quot;-O2 -g&quot; make CC=gcc CXX=g++</pre>
</dd>
<dt><strong><a name="make" class="item"><strong>make</strong></a></strong></dt>

<dd>
<p>Synonym for command <strong>[build]</strong>.</p>
</dd>
<dt><strong><a name="dist_real_clean" class="item"><strong>[dist|real]clean</strong></a></strong></dt>

<dd>
<p>Run any <em>make</em> target whose name ends to <code>clean</code>. That is: clean,
distclean, realclean etc.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="install_commands__in_order_of_execution_">Install commands (in order of execution)</a></h2>
<dl>
<dt><strong><a name="strip" class="item"><strong>strip</strong></a></strong></dt>

<dd>
<p>Strip <code>*.exe</code> and <code>*.dll</code> files under <code>package-N.N/.inst/</code></p>
</dd>
<dt><strong><a name="install" class="item"><strong>install</strong></a></strong></dt>

<dd>
<p>Install package to directory <code>package-N.N/.inst/</code>. If use supplied
<code>package-N.N/CYGWIN-PATCHES/install.sh</code> exist, run it instead of normal:</p>
<pre>
    make install</pre>
<p>When porting for the first time, accompany this command with the test
option <strong>-t</strong> so that no harm is done even if Makefile would try to place
files to weird places.</p>
<pre>
    cygbuild --release 1 --test install</pre>
</dd>
<dt><strong><a name="check" class="item"><strong>check</strong></a></strong></dt>

<dd>
<p>Run various checks to ensure that the install to directory .inst/ look
good. It is highly recommended that you use this command with verbose
option <strong>--verbose</strong>. Some of the checks include:</p>
<pre>
    - Check that there is no temporary files in install directory
    - Check that package.README looks ok
    - Check if there are info files, but no postinstall script to
      install those info files.
    - Check that all executables also have associated manual pages
      Each program should have manual page, even if it only
      suggests looking elsewhere.
    - etc.</pre>
<p>The directory being checked is <code>./.inst</code> by default, but this
can be changed, e.g. if checking some other package's install
results:</p>
<pre>
    cygbuild --cyginstdir /other/path/.inst --verbose check</pre>
<p>See also description of option <strong>--file</strong> how to check other
developer's binary packaging.</p>
<p>See also command <strong>[test]</strong>.</p>
</dd>
<dt><strong><a name="check_deps" class="item"><strong>check-deps</strong></a></strong></dt>

<dd>
<p>Check that all dependencies are listed in <code>package.README</code> and
<code>setup.hint</code>. It is highly recommended that you use this command with
verbose option <strong>--verbose</strong>.</p>
</dd>
<dt><strong><a name="postinstall" class="item"><strong>postinstall</strong></a></strong></dt>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/postinstall.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#postinstall_sh"><code>postinstall.sh</code></a> script if it is
supplied.</p>
</dd>
<dt><strong><a name="preremove" class="item"><strong>preremove</strong></a></strong></dt>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/preremove.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#preremove_sh"><code>preremove.sh</code></a> script if it is
supplied.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="packaging_commands">Packaging commands</a></h2>
<dl>
<dt><strong><a name="mkpatch" class="item"><strong>mkpatch</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/diff.sh</code>. If it does not exists,
run diff between original package and current modifications. You must:</p>
<pre>
  1. chdir to directory C&lt;package-N.N/&gt;
  2. Provide original package directly above current run
     directory; that is ../
     (See option -f in case source cannot be found by the program)</pre>
</dd>
<dt><strong><a name="package" class="item"><strong>package</strong></a></strong></dt>

<dd>
<p>Make binary package <code>PACKAGE-VERSION-REL.tar.xz</code> to directory <code>.sinst/</code>.</p>
</dd>
<dt><strong><a name="package_devel_or_pkgdev" class="item"><strong>package-devel</strong> or <strong>pkgdev</strong></a></strong></dt>

<dd>
<p>For library distributions, this command splits the binary distribution into
three categories:</p>
<pre>
    libPACKAGE-N.N-REL.tar.xz       *.dll from  usr/
    libPACKAGE-devel-N.N-REL.tar.xz all   from  usr/include  usr/lib
    libPACKAGE-doc-N.N-REL.tar.xz   all   from  usr/doc      usr/man</pre>
<p>The prefix 'lib' is not added in front of PACKAGE if PACKAGE name already
starts with string 'lib'. In order to make a library release, there must be
separate setup hint files for each in directory <code>CYGWIN-PATCHES/</code>.
Program will warn if any of these are missing</p>
<pre>
     setup.hint             for the runnable *.dll
     setup-devel.hint       for the development libraries *.a *.la
     setup-bin.hint         Client files from usr/bin/
     setup-doc.hint         for the documentation</pre>
<p>When command <strong>[publish]</strong> is run, these setup files and the generated xz
files are copied to appropriate release directories like this:</p>
<pre>
    ROOT   ( $CYGBUILD_PUBLISH_DIR/libpackage/ )
    |
    | setup.hint
    | libPACKAGE-N.N-REL.tar.xz
    | libPACKAGE-N.N-REL-src.tar.xz
    |
    +-devel
    | libPACKAGE-devel-N.N-REL.tar.xz
    | setup.hint (was setup-devel.hint)
    |
    +-bin
    | libPACKAGE-bin-N.N-REL.tar.xz
    | setup.hint (was setup-bin.hint)
    |
    +-doc
      libPACKAGE-doc-N.N-REL.tar.xz
      setup.hint (was setup-doc.hint)</pre>
<p>Take for example a sample garbage collection library, whose name is simply
'gc' available at &lt;http://www.hpl.hp.com/personal/Hans_Boehm&gt;. There
are no executable files in. You should not use the name <code>gc</code> to package
this. The problem is the initial unpack directory name <code>gc-6.2.1.6</code> which
is used to generate the package names. The following is not optimal:</p>
<pre>
    cd /usr/src/build</pre>
<pre>
    .. make sure contains only source file</pre>
<pre>
    tar zxvf gc6.2alpha6.tar.gz
    cd gc6.2alpha6  gc-6.2.1.6</pre>
<pre>
    cygbuild mkdirs files conf make</pre>
<pre>
    .. edit README and setup.hint
    .. Now make binary package for this library</pre>
<pre>
    cygbuild package-devel</pre>
<pre>
    -- Making packages [devel] from /usr/src/build/gc-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc-6.2.1.6-1.tar.xz
    --   [devel-doc] /usr/src/build/gc-doc-6.2.1.6-1.tar.xz
    --   [devel-dev] /usr/src/build/gc-devel-6.2.1.6-1.tar.xz</pre>
<p>It would be better to use the <code>libgc6</code> name, as it is used in Debian,
instead of the homepage's name <code>gc</code>, like this:</p>
<pre>
    .. Unpack as above, but symlink to 'lib' directory</pre>
<pre>
    ln -s gc6.2alpha6  libgc6-6.2.1.6
    cd libgc6-6.2.1.6</pre>
<pre>
    .. likewise as above for the configure, make etc. and finally ...</pre>
<pre>
    cygbuild package-devel</pre>
<pre>
    -- Making packages [devel] from /usr/src/build/libgc6-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc6-6.2.1.6-1.tar.xz
    --   [devel-doc] /usr/src/build/libgc6-doc-6.2.1.6-1.tar.xz
    --   [devel-dev] /usr/src/build/libgc6-devel-6.2.1.6-1.tar.xz
                                    ======</pre>
<p>Notice how all released files now correctly include prefix <code>libgc6</code>.</p>
</dd>
<dt><strong><a name="source_package_or_spkg" class="item"><strong>source-package</strong> or <strong>spkg</strong></a></strong></dt>

<dd>
<p>Make source package <code>PACKAGE-VERSION-REL-src.tar.b2</code> to directory
<code>.sinst/</code>. This command will first run <strong>[clean]</strong> followed by
<strong>[mkpatch]</strong>. This means that all object files and files that can be
generated will be wiped away as if:</p>
<pre>
    make clean distclean</pre>
<p>was called. So, to build binary package after command <strong>source-package</strong>
means that the steps have to be started over. Like this:</p>
<pre>
    cygbuild --release 1 configure make install package</pre>
</dd>
<dt><strong><a name="readmefix" class="item"><strong>readmefix</strong></a></strong></dt>

<dd>
<p>Update files in <code>CYGWIN-PATCHES/*</code> to reflect current package's
mainteiner, version and release numbers. E.g. 'Cygwin port maintained
by' and Copyright statements and any <code>Firstname Lastname</code>, <code>PKG</code>,
<code>VER</code>, <code>REL</code> tags are replaced with the correct values (see
ENVIRONMENT). Remember to supply <strong>--release REL</strong> with this command.</p>
<p>Files with  <em>*.tmp</em> extension are ignored.</p>
</dd>
<dt><strong><a name="finish" class="item"><strong>finish</strong></a></strong></dt>

<dd>
<p>Remove source unpack directory <code>package-N.N/</code>. This command is
dangerous. It might be better to use <code>rm(1)</code> manually.</p>
<p>Really, user should never run this command. It is mostly reserved for
internal build process testing command <strong>[all]</strong>.</p>
</dd>
<dt><strong><a name="publish" class="item"><strong>publish</strong></a></strong></dt>

<dd>
<p>If environment variable <code>CYGBUILD_PUBLISH_BIN</code> is set, the external
program is called with 3 mandatory and 2 optional arguments from
options <strong>--sign</strong> and <strong>--passphrase</strong> if those were supplied. The
shell call will be in form:</p>
<pre>
    $CYGBUILD_PUBLISH_BIN \
        /directory/where/package-N.N/.sinst/
        &lt;package string&gt;
        &lt;version string&gt;
        &lt;release number&gt;
        [gpg sign id]
        [gpg pass phrase]</pre>
<p>If no <code>CYGBUILD_PUBLISH_BIN</code> exists, source and binary packages are copied
to directory <code>$CYGBUILD_PUBLISH_DIR/package/</code>.</p>
<p>It makes sense to run publish command only after commands
<strong>[source-package]</strong> and <strong>[package]</strong>. If command <strong>[package-devel]</strong>
was used, then the published files are copied to a separate
subdirectories below <code>$CYGBUILD_PUBLISH_DIR/package/</code>. See command
<strong>[package-devel]</strong> for more information.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="digital_signature_commands">Digital signature commands</a></h2>
<dl>
<dt><strong><a name="sign" class="item"><strong>sign</strong></a></strong></dt>

<dd>
<p>Sign all created packages and the <strong>*.patch</strong> under directory <code>.sinst/</code>.
Commands <strong>[package]</strong> and <strong>[source-package]</strong> can accept sign key option
<strong>--sign</strong> which add the digital signature to archives after they have been
built. Only if you accidentally remove the <code>*.sig</code> files, or if you forgot
to use signing options, you need to separately call this command.</p>
<p>or archive builds.</p>
</dd>
<dt><strong><a name="verify" class="item"><strong>verify</strong></a></strong></dt>

<dd>
<p>Verify all signatures belonging to current package in current directory or
in <code>.sinst/</code>.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="patch_management_commands">Patch management commands</a></h2>
<dl>
<dt><strong><a name="patch" class="item"><strong>patch</strong></a></strong></dt>

<dd>
<p>Apply all <em>*.patch</em> files found recursively under <code>CYGWIN-PATCHES/</code>
to original sources (see command <strong>patch-list</strong>). files in direcories
<code>/tmp/</code> or <code>/*.tmp/</code> are disregarded. The applied patches are
recorded in <code>CYGWIN-PATCHES/done-patches.tmp</code> so that they won't be
applied multiple times.</p>
<p>The directories and filenames are best to be prefixed with a
sequential number, like:</p>
<pre>
  0001-Makefile-rewrite-install.patch
  0002-command.c-add-ifdef-Cygwin.patch</pre>
<p>The filenames can include extra <em>strip+N</em> keyword to instruct what is
the <strong>--strip=N</strong> option that should be passed to command patch(1):</p>
<pre>
    &lt;package&gt;-*.strip+N.patch</pre>
<p>An example:</p>
<pre>
    package-1.2-this-fixes-segfault.strip+2.patch</pre>
<p>NOTE: The use of <em>strip+N</em> argument is usually unnecessary, because
the program heuristics can in most cases determine what is the proper
<strong>--strip</strong> option to <strong>patch(1)</strong> command.</p>
<p>See also command <strong>[unpatch]</strong>.</p>
</dd>
<dt><strong><a name="patch_check_pchk" class="item"><strong>patch-check|pchk</strong></a></strong></dt>

<dd>
<p>Display content of <code>CYGWIN-PATCHES/done-patches.tmp</code> if any and list
filenames from result of command <strong>[mkpatch]</strong>.</p>
</dd>
<dt><strong><a name="patch_list_plist" class="item"><strong>patch-list|plist</strong></a></strong></dt>

<dd>
<p>Display patch list of <code>CYGWIN-PATCHES/</code>. The order is apply order.
Effectively runs command:</p>
<pre>
    find CYGWIN-PATCHES -name &quot;*.patch&quot; | sort</pre>
</dd>
<dt><strong><a name="unpatch" class="item"><strong>unpatch</strong></a></strong></dt>

<dd>
<p>Deapply all *.patch files found using <code>find(1)</code>, followed by <code>sort(1)</code>,
under <code>CYGWIN-PATCHES</code>. On success, the record keeping file
<code>CYGWIN-PATCHES/done-patches.tmp</code> is deleted. The opposite of
<strong>[patch]</strong> command.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="other_commands">Other commands</a></h2>
<dl>
<dt><strong><a name="all" class="item"><strong>all</strong></a></strong></dt>

<dd>
<p>Run all relevant steps: <strong>prep, conf, build, install, strip, package,
source-package, finish</strong>. This command is used to test the integrity of
Cygwin net release. Like this:</p>
<pre>
    tar -xvf package-N.N-1-src.tar.xz
        package-N.N-1.sh
        package-N.N-1.patch
        package-N.N-src.tar.gz</pre>
<pre>
    ./package-N.N-1.sh all</pre>
<p>If the build process breaks, then the fault is in the packaging.
Contact maintainer of <code>package-N.N-1-src.tar.xz</code> for details.</p>
</dd>
<dt><strong><a name="almostall" class="item"><strong>almostall</strong></a></strong></dt>

<dd>
<p>Same as command <strong>[all]</strong> but without the <strong>[finish]</strong> step.</p>
</dd>
<dt><strong><a name="cygsrc_a_arch_x86_x86_64_b_binary_c_clean_dir_d_package" class="item"><strong>cygsrc [-a|--arch {x86,x86_64}] [-b|--binary] [-c|--clean] [--dir|-d] PACKAGE</strong></a></strong></dt>

<dd>
<p>NOTES: 1) This command must be run at an empty directory and 2) No
other command line options are interpreted. This is a stand alone
command.</p>
<p>Download Cygwin package. By default according to the current
architecture unless options <strong>--arch</strong> is used; this options must
appear at the beginning. If option <strong>--dir</strong> is given, create directory
with name <em>PACKAGE</em>, cd to it and start downloading <em>PACKAGE</em>. If
option <strong>--binary</strong> is given, download only binary package.</p>
<p>When run for the first time, the list of packages listed in
<em>setup.ini</em> is cached under directory <code>/var/cache/cygbuild</code>. Use option
<strong>--clean</strong> to immediately remove cache to notice new updates. The cache
file is updated automatically if it's more than 7 days.</p>
<p>This command is primarily used for downloading sources of orphaned
package in order to prepare ITA (intent to adopt) to Cygwin
application mailing list.</p>
<pre>
  1. The content of *-src.tar.xz and setup.hint are store
  2. the *.xz is unpacked
  3. the CYGWIN-PATCHES is extracted from *.patch
  4. the rest of the patches (excluding CYGWIN-PATCHES) is stored
     to *-rest.patch</pre>
<p>See ENVIRONMENT for changing the download URL location to closer
local Cygwin package mirror site.</p>
</dd>
<dt><strong><a name="download" class="item"><strong>download</strong></a></strong></dt>

<dd>
<p>Check upstream site for new versions. External program <em>mywebget.pl</em>
<a href="http://freecode.net/projects/perlwebget">http://freecode.net/projects/perlwebget</a> is used to do the download. The
configuration file <code>CYGWIN-PATCHES/upstream.perl-webget</code> must contain URL
and additional parameters how to retrieve newer versions. See
<em>mywebget.pl</em>'s manual for more information. Here is an example
configuration file to download and extract new versions of package:</p>
<pre>
  tag1: package
    <a href="http://example.com/project/package-0.9.1.tar.xz">http://example.com/project/package-0.9.1.tar.xz</a> new: x:</pre>
</dd>
<dt><strong><a name="prepare" class="item"><strong>prepare</strong></a></strong></dt>

<dd>
<p>This command is not part of the porting commands. It is meant to be used as
a preparation to build Cygwin Net release source package from scratch.
Something like -b option in &quot;source build&quot; commands in <code>.deb</code> and <code>.rpm</code>
packaging managers.</p>
<p>Extract <code>package-VERSION-REL-src.tar.xz</code> to current directory and apply
patch <code>package-VERSION-REL*.patch</code> and run build command <strong>[makedirs]</strong>.</p>
</dd>
<dt><strong><a name="reshadow" class="item"><strong>reshadow</strong></a></strong></dt>

<dd>
<p>Regenerate all links. Run this command if a) changes are made to the
original source by adding or removing files or b) you've moved the sources
to another directory and the previous links become invalid. Effectively
runs <strong>[rmshadow]</strong> and <strong>[shadow]</strong>. Notice that all compile objects files
are gone too, so you need to recompile everything.</p>
</dd>
<dt><strong><a name="rmshadow" class="item"><strong>rmshadow</strong></a></strong></dt>

<dd>
<p>Remove shadowed source directory recursively. The directory root
is preserved. If you move the original directory to another place, the
shadowed source file links become invalid.</p>
</dd>
<dt><strong><a name="shadow" class="item"><strong>shadow</strong></a></strong></dt>

<dd>
<p>Copy all files from source directory to build directory. The source files
are shadowed by drawing symbolic links to directory <code>./build/build</code>.
The compilation will done there. Usually this command can be replaced with
command <a href="#reshadow"><code>[reshadow]</code></a>.</p>
<p>This command is not usually needed, because the <strong>[configure]</strong> will notice
missing shadow directory and make it as needed.</p>
</dd>
<dt><strong><a name="test" class="item"><strong>test</strong></a></strong></dt>

<dd>
<p>Run <em>make test</em> and possibly additional executable files listed in
<code>CYGWIN-PATCHES/test</code> directory. The PATH is set to include all
directories found under <code>.inst</code> so that programs in <a href="#test"><code>test/</code></a>
directory can can assume that package binaries &quot;are installed&quot;.</p>
<p>Complex packages that need access to their libraries, Perl/Python
modules or data cannot be tested without live install first. Merely
setting the PATH wouuld not be enough, but instead:</p>
<pre>
   tar -C / -xf .sinst/&lt;packge&gt;.tar.xz    # Install for real; live install
   cygbuild --verbose test                # run CYGWIN-PATCHES/test/*</pre>
<p>To arrange running tests, I might be good a idea to prefix filenames
with numbers to have them sort in specific order. Any file that does
not have the <strong>-x</strong> flag set is ignored; these files can be used e.g.
for README to clarify the test suite. Make each test command to output
a brief test description to stdout.</p>
<pre>
   $ ls CYGWIN-PATCHES/test
   README
   01-read.sh
   02-write.sh
   ...</pre>
<p>Tests can also be run manually (supposing live install):</p>
<pre>
   ./CYGWIN-PATCHES/test/01-read.sh</pre>
</dd>
<dt><strong><a name="vars" class="item"><strong>vars</strong></a></strong></dt>

<dd>
<p>Print variables and quit. Use this option to see what files and directories
program thinks that it will be using.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></h1>
<p>
</p>
<h2><a name="preliminary_setup">Preliminary setup</a></h2>
<p>1. Create an empty directory, copy original source package there and unpack
it</p>
<pre>
    mkdir -p /tmp/build/
    cd /tmp/build                   &lt;&lt; go here</pre>
<pre>
    rm *
    cp /tmp/package-1.13.tar.gz .
    tar zxvf package-1.13.tar.gz</pre>
<p>2. Test and verify that you can compile package. Run <a href="#configure"><code>./configure</code></a>,
<code>./buildconf</code>, <code>./autogen.sh</code> or <code>./autoconf</code> (if the package includes
only <code>*.in</code> files) as needed. In case of errors, use Google, search
mailing lists, talk to maintainers and find solutions until you can build
package without errors. Modify the files in place as long as it takes to
get package to build. <strong>Do not proceed to other steps until the build
succeeds</strong>.</p>
<pre>
    cd package-1.13/
    .. run ./config or whatever is needed
    .. run make(1). Oops, did not work, edit &amp; fix</pre>
<p>3. [this step is optional] Take a diff of your current changes and move the
diff file to safe place. Knowing that you are secured in case something
goes wrong, greatly reduces your stress when you know you don't have to
start all from scratch. Alternatively use some source control tool right
from the start.</p>
<pre>
    .. you're at directory package-N.N/
    cygbuild mkpatch
    find .sinst/ -name &quot;*patch&quot;    &lt;&lt; copy this to safe place</pre>
<p>
</p>
<h2><a name="now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></h2>
<p>4. Stay at directory <code>package-N.N/</code> and run few commands, which make
additional Cygwin directories and template files. If this is the first
release, add build release option <strong>-r 1</strong>. Remember to increase build count
if you make more releases of the same package.</p>
<pre>
    cd /tmp/build/package-1.13/
    cygbuild -r 1 -v mkdirs files</pre>
<p>Command <strong>[mkdirs]</strong> created three dot-directories which should be
<code>package-1.13/{.build,.inst,.sinst}</code>. Command <strong>[files]</strong> wrote few template
files of which two must be modified. The other <code>.tmp</code> files are just
examples they are needed for tricky packages.</p>
<pre>
    cd /tmp/build/package-1.1/CYGWIN-PATCHES/</pre>
<p>Make sure you README and hint files are edited before preceding to building
binary and source packages. If any of the extra scripts are needed, remove
extension <code>.tmp</code> from them to make the scripts active.</p>
<pre>
    package.README      Modify this file and fill in the '&lt;Headings&gt;:'
    setup.hint          Modify this file</pre>
<pre>
    install.sh.tmp      optional; if 'make install' does not do it
    postinstall.sh.tmp  optional; things to do after installation
    build.sh.tmp        optional; if 'make all' does not do it</pre>
<p>5. Preparations are now ready. It's time to make Cygwin Net release binary
packages. It will appear in directory <code>./.sinst</code>:</p>
<pre>
   cd /tmp/build/package-1.13/
   cygbuild -r 1 -v install strip package</pre>
<p>6. Examine carefully the install phase and double check that the created
archive looks correct. Run <code>find(1)</code> to check the directory structure:</p>
<pre>
   cd /tmp/build/package-1.13/
   find .inst/ -print
   cygbuild -r 1 -v check      &lt;&lt; Run various checks</pre>
<p>Did the manual pages (*.1, *.5, *.8 etc.) got installed correctly under
<code>usr/share/man/manX/</code>? How about <code>*.info</code> files at <code>usr/share/info</code>? Are
the libraries <code>.a</code> and <code>.la</code> or <code>*dll*</code> under <code>usr/lib</code>? Are
executables under <code>usr/bin</code>? If everything is not in order, then you need
to study the package's <code>Makefile</code> and fix it to put files in proper
locations.</p>
<p>Here is a shortened listing of a typical library package:</p>
<pre>
    usr/lib/libgc.la
    usr/lib/libgc.a
    usr/man/man3/gc.3
    usr/share/doc/gc-6.1/README.QUICK
    usr/share/doc/gc-6.1/README
    usr/share/doc/gc-6.1/debugging.html
    usr/share/doc/gc-6.1/gc.man
    usr/share/doc/gc-6.1/gcdescr.html
    usr/share/doc/gc-6.1/leak.html
    usr/share/doc/gc-6.1/tree.html
    usr/share/doc/Cygwin/gc-6.1.README</pre>
<p>And here is a shortened listing from a typical executable package:</p>
<pre>
    etc/postinstall/glimpse.sh
    usr/bin/glimpseindex.exe
    usr/bin/glimpse.exe
    usr/bin/glimpseserver.exe
    usr/share/man/man1/glimpse.1
    usr/share/man/man1/glimpseindex.1
    usr/share/man/man1/glimpseserver.1
    usr/share/man/man1/agrep.1
    usr/share/doc/glimpse-4.17.4/CHANGES</pre>
<p>7. Building source packages is much harder, because the program needs to
know more details about configure and build phases. If the default source
packaging command <strong>[source-package]</strong> does not succeed, you probably have
to guide the process slightly by the shell scripts provided under directory
<code>package-N.N/CYGWIN-PATCHES/</code>. Try this first:</p>
<pre>
   .. you are still in directory package-N.N/
   cygbuild -r 1 -v source-package</pre>
<p>That's it, if all succeeded. At directory up <code>./.sinst</code> you should see two
complete Cygwin Net release shipments: a binary package and a source
package. The RELEASE number is the result of the <strong>-r</strong> option.</p>
<pre>
    package-1.13-1.tar.xz
    package-1.13-1-src.tar.xz</pre>
<p>
</p>
<h2><a name="contributing_packages">Contributing packages</a></h2>
<p>Refer to &quot;Submitting a package&quot; at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for
full description.</p>
<p>To contribute your package, place them somewhere available and send message
to &lt;<a href="mailto:cygwin-apps@cygwin.com">cygwin-apps@cygwin.com</a>&gt; with following message. The ITP acronym used is
borrowed from Debian and it means &quot;intent to package&quot;:</p>
<pre>
    Subject: ITP: package-N.N</pre>
<p><strong>Package submittal:</strong> Include contents of <code>setup.hint</code> and the binary
package listing <code>tar jtvf package-1.13-RELEASE.tar.xz</code>. Provide
*complete* clickable ULR links where to download the files. An example:</p>
<pre>
    wget \
        <a href="http://example.com/cygwin/package/package-N.N-1-src.tar.xz">http://example.com/cygwin/package/package-N.N-1-src.tar.xz</a> \
        <a href="http://example.com/cygwin/package/package-N.N-1.tar.xz">http://example.com/cygwin/package/package-N.N-1.tar.xz</a> \
        <a href="http://example.com/cygwin/package/setup.hint">http://example.com/cygwin/package/setup.hint</a></pre>
<p><strong>Licensing:</strong> As a package maintainer, the licensing responsibility is on
your shoulders. If the upstream package's license if not OSD compatible
(see &lt;http://www.opensource.org/docs/definition_plain.html&gt;) there may be
problems, as the Cygwin glue code (libcygwin.a) is linked in on all
cygwin-targets, thus rendering the compiled result GPL'd (see
<a href="http://www.cygwin.com/licensing.html">http://www.cygwin.com/licensing.html</a> ), unless the license is OSD
approved; see <a href="http://www.opensource.org/licenses/">http://www.opensource.org/licenses/</a> for list.</p>
<p>The Cygwin net release is a volunteer effort. If you, the volunteer, do not
feel comfortable with the licensing, then ask for advice on the cygwin-apps
mailing list.</p>
<p><strong>TTL; Time To Live:</strong> If a submitted package has been on the pending
packages list for two months or more, without receiving any votes or no
follow-ups (when requested) it may be dropped from the list. You can
re-submit your package again at a later time, if you choose to do so.
Packages that are already included in major Linux distributions like
Debian, Ubuntu, Redhat, SUSE, Gentoo, Slackware do not need voting
procedure. Mention the link to the distribution page where package is
maintained.</p>
<p><strong>Publishing:</strong> In case you're running Apache web server and world known IP
address, you can publish your files to the world directly. Add this line to
your <code>httpd.conf</code> and make <code>apache(1)</code> read configuration again with
<em>apachectl restart</em>. Check that your connection can see the files with
<code>lynx(1)</code>.</p>
<pre>
    # httpd.conf
    Alias /cygwin /usr/src/cygwin-packages</pre>
<p>As a finishing touch, there is command command <strong>[publish]</strong> which copies
ready source package, binary package and setup.hint to publish area:</p>
<pre>
   .. you're still at directory package-N.N/
   cygbuild publish</pre>
<p>
</p>
<hr />
<h1><a name="gpg_examples">GPG EXAMPLES</a></h1>
<p>Let's assume that you have added following build alias command to your
<code>~/.bashrc</code>:</p>
<pre>
    alias cb=&quot;cygbuild --color --sign $GPGKEY&quot;</pre>
<p>You don't want the second alias presented below to be stored in
permanent places, because it contains your GPG identification details.
Copy/paste if to opern terminals as needed.</p>
<pre>
    alias bb=&quot;cygbuild -s gpg-key-id -p 'gpg-password'&quot;</pre>
<p>Assuming there already unpacked original package, which has been tested to
build correctly, it's a simple matter of making GPG signed releases.
Perhaps there is something in <code>*.README</code> that needs some correction or
final words. Maybe it had typos. Or <code>setup.hint</code> needed updating. Okay,
run this to make new install which replaced older <code>*.README</code> file:</p>
<pre>
    cd package-1.13/
    cb -r 1 -v install check</pre>
<p>Look closely at the results of check command. If anything needs to be
edited or corrected, repeat the command after edit. Verify the
installation:</p>
<pre>
    find .inst/ -print | sort</pre>
<p>If all looks good, the signed packages can be made. If you don't have gpg
installed, then substitute plain &quot;b&quot; instead of for &quot;bb&quot; below:</p>
<pre>
    bb -r 1 package source-package</pre>
<p>In case there is permanent Internet connection where files can be put to a
publish area (Apache, Ftp), the last step copies packages elsewhere on
local disk:</p>
<pre>
    bb 1 publish</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></h1>
<p>
</p>
<h2><a name="bin__directory">bin/ directory</a></h2>
<p>All files in <code>CYGWIN-PATCHES/bin</code> are installed as executables (with
permissions 755) into directory <code>.inst/usr/bin</code>. Files with extension
<code>*.tmp</code> are ignored.</p>
<p>The location of each installd file can be by adding tag
<em>cyginstdir:</em>. An example:</p>
<pre>
    #!/bin/sh
    # cyginstdir: /bin
    ...</pre>
<p>If it is not practical to insert <em>cyginstdir:</em> stanza to a file that
may be original copy from somewhere else (updated each time new
version comes), the directory can be also be set in a separate file:</p>
<pre>
   &lt;file&gt;.cyginstdir</pre>
<p>The file must contain one line with full path name for install
location. An optional <strong>install(1)</strong> permission expression can
specified in the end of path line. Any comment lines starting with &quot;#&quot;
are ignored. An example:</p>
<pre>
   # comment
   /bin/program 755</pre>
<p>
</p>
<h2><a name="man__directory">man/ directory</a></h2>
<p>All files in <code>CYGWIN-PATCHES/man</code> are installed as manual pages. The
file must end to a number indicating the manual page section. Examples:</p>
<pre>
   manpage.1
   manpage.conf.5</pre>
<p>
</p>
<h2><a name="patches__directory">patches/ directory</a></h2>
<p>Files in <code>CYGWIN-PATCHES/patches</code> with extensin *.path are used with
the <strong>patch</strong> and <strong>unpatch</strong> commands. The order of files are
determined by sorting them alphabetically. To ensure correct patch
order, please add numeric prefix for each file and add patches to
their respective subdirectories.</p>
<p>If there is a <code>series</code> file in a directory, <strong>quilt(1)</strong> is invoked to
handle the patches. NOTE: Due to implementation of quilt, there can
only be a single <code>series</code> file. This is because quilt keeps status
information in toplevel <code>.pc/</code> directory and it does not chnage it
even though a different source directory for <code>series</code> file had been
given by setting environment variable <em>QUILT_PATCHES</em>. In short:
managing multiple quilt instances in separate directories is not
possible.</p>
<p>An example: files in 00debian/ directory are applied before files in
cygwin/ directory due to alphabetical order. In this example the
patches from Debian (managed by quilt) are combined with those
specific to Cygwin:</p>
<pre>
   CYGWIN-PATCHES/
   |
   +- patches/
      |
      +- 00debian-0.15-1/
      |  ...
      |  series  (quilt patch series file)
      |
      +- cygwin/
         10-fix-makefile.patch</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_files">OPTIONAL EXTERNAL FILES</a></h1>
<p>The following list of scripts is alphabetically ordered. The name of
the script indicates when it is run or which command runs it. All
files in <code>CYGWIN-PATCHES/</code> that have suffix <code>.tmp</code> or <code>.ex</code> are
temporary files or templates, and not used.</p>
<dl>
<dt><strong><a name="build_options" class="item"><strong>build.options</strong></a></strong></dt>

<dd>
<p>If this file exists, it is sourced to read custom flags and other <em>make(1)</em>
options. The content of the file should be like this. These are the default
values</p>
<pre>
  CYGBUILD_CFLAGS=&quot;-O2 -g&quot;
  CYGBUILD_LDFLAGS=&quot;&quot;          # set to -no-undefined for libraries
  CYGBUILD_MAKEFLAGS=&quot;CC=gcc CXX=g++&quot;</pre>
<p>And they are used in a call to initialize <a href="#make"><code>make(1)</code></a> variables in call like
this:</p>
<pre>
  make CFLAGS=&quot;$CYGBUILD_CFLAGS&quot;   \
       LDFLAGS=&quot;$CYGBUILD_LDFLAGS&quot; \
       $CYGBUILD_MAKEFLAGS</pre>
</dd>
<dt><strong><a name="build_sh" class="item"><strong>build.sh</strong></a></strong></dt>

<dd>
<p>Perhaps simple <code>make all</code> did not compile the package. In that case a custom
<code>CYGWIN-PATCHES/build.sh</code> can be used to give correct options and
commands:</p>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives three arguments: package name, version and
      release number.</pre>
<pre>
    make ... whatever options are needed ...
    make ... perhaps it need other targets as well ...</pre>
</dd>
<dt><strong><a name="configure_guess_configure_sub" class="item"><strong>configure.guess</strong> <strong>configure.sub</strong></a></strong></dt>

<dd>
<p>If these files exists, they are copied to the sources directories
overwriting the previous definitions.</p>
<p>Use case: with old packages the files <code>config.{guess,sub}</code> may be
very old and not suitable for detecting the build environmnet. It may
be possible to build with newer copies of these files. The latest
versions are available in Debian package <em>autotools-dev</em> Git repository
at <a href="http://anonscm.debian.org/cgit/users/hmh/autotools-dev.git/tree/">http://anonscm.debian.org/cgit/users/hmh/autotools-dev.git/tree/</a></p>
</dd>
<dt><strong><a name="configure_env_options" class="item"><strong>configure.env.options</strong></a></strong></dt>

<dd>
<p>If this file exists, it is sourced to read custom environment settings just
before <a href="#configure"><code>./configure</code></a> is being run.</p>
<pre>
    source configure.env.options</pre>
<p>For example to use <strong>ccache gcc</strong> with autotool packages (these with
configure.in, Makefile.am etc) to speed up compilation, there is example
script <code>CYGWIN-PATCHES/compiler.sh.tmp</code> which you can take into use by
removing the <code>.tmp</code> extension. After put this line to the file. Notice
that there is no path in front of <code>compiler.sh</code> because during the
execution the <strong>PATH</strong> variable will include also <code>CYGWIN-PATCHES/</code>.</p>
<pre>
    # Start of CYGWIN-PATCHES/configure.env.options
    CYGBUILD_CC=compiler.sh
    # End of file</pre>
</dd>
<dt><strong><a name="configure_options" class="item"><strong>configure.options</strong></a></strong></dt>

<dd>
<p>If this file exists, all options in this file are appended to the default
Cygwin options set during call to <a href="#configure"><code>./configure</code></a>. Comments may be added to
preceding lines with a hash-mark. An example:</p>
<pre>
    # Include these options during configure:
    --disable-static        # Do not use static libraries
    --enable-tempstore
    --enable-threadsafe
    --with-tcl=/usr</pre>
</dd>
<dt><strong><a name="configure_sh" class="item"><strong>configure.sh</strong></a></strong></dt>

<dd>
<p>In case the package does not include a standard GNU <a href="#configure"><code>./configure</code></a>
script, a custom script <code>CYGWIN-PATCHES/configure.sh</code> can guide all
configure steps. If there is nothing to configure, leave this script
out. For the custom program:</p>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives one argument: absolute path to install root
      directory (that'd be &lt;path&gt;/package-N.N/.inst)</pre>
<p>To start with the custom script, here are the standard Cygwin configure
switches, which you can incorporate:</p>
<pre>
    ./configure
        --target=i686-pc-cygwin
        --srcdir=/usr/src/cygbuild/package/package-N.N
        --prefix=/usr
        --exec-prefix=/usr
        --sysconfdir=/etc
        --libdir=/usr/lib
        --includedir=/usr/include
        --localstatedir=/var
        --libexecdir='${sbindir}'
        --datadir='${prefix}/share'</pre>
</dd>
<dt><strong><a name="delete_lst" class="item"><strong>delete.lst</strong></a></strong></dt>

<dd>
<p>See also <a href="#install_lst"><code>install.lst</code></a>.</p>
<p>List <code>rm(1)</code> compatible entries in separate lines. The
format is:</p>
<pre>
  # comment
  &lt;file or directory or a glob pattern&gt; [rm option]</pre>
<p>Expansion variables available are: <code>$PKG</code> for package name, <code>$VER</code>
for version number and <code>$DOC</code> for package specific documentation
directory. Notice that the <em>destination</em> must not be an absolute path
but a relative one under <em>.inst/</em> directory.</p>
<p>Examples:</p>
<pre>
  # The file and directory PATTERN can use variables $PKG $VER $DOC.
  # Examples:</pre>
<pre>
  $DOC/example -rf
  *.uml</pre>
</dd>
<dt><strong><a name="diff_options" class="item"><strong>diff.options</strong></a></strong></dt>

<dd>
<p>By default the <a href="#patch"><code>[patch]</code></a> command excludes files that it thinks do not
belong there, but in many case package generate other extra files that
should be excluded too. In this file it is possible to supply extra options
to <code>diff(1)</code> while comparing the original source directory against the
current package directory. The options to diff must be listed one line at a
time. Comments can start with hash-character.</p>
<pre>
    # diff.options -- exclude these files from patch</pre>
<pre>
    --exclude=Makefile.in
    --exclude=Makefile</pre>
<pre>
    # End of file</pre>
<p>There a re couple of options that affect cygbuild itself. If following
option is found, then no automatic guessing what files might have been
auto-generated, is done. This is effectively a pseudo option that
says &quot;turn off internal check&quot;:</p>
<pre>
    --exclude=cygbuild-ignore-autochecks</pre>
<p>To completely suppress all default cygbuild exclude options like those
of <code>*.~, *# *.orig</code> and other files), start the file with use this
line:</p>
<pre>
    --exclude=cygbuild-ignore-all-defaults</pre>
<p><strong>Warning:</strong> due to shell expansions in the program, it is not possible
to use wildcards with short option names, like this:</p>
<pre>
    -x *.tmp</pre>
<p>Please use the long option notation instead:</p>
<pre>
    --exclude=*.tmp</pre>
</dd>
<dt><strong><a name="diff_before_sh" class="item"><strong>diff-before.sh</strong></a></strong></dt>

<dd>
<p>When the original source has been unpacked, it may include files that
prevent taking clean diff. IT could happen that the source package
mistakenly included compiled object files or included dangling symlinks to
the original authors files. This is the chance to &quot;straighten up&quot; things
before diff engages.</p>
</dd>
<dt><strong><a name="diff_sh" class="item"><strong>diff.sh</strong></a></strong></dt>

<dd>
<p>Sometimes the default <strong>[mkpatch]</strong> command - which runs <code>diff(1)</code> with
conservative set of options - is not enough. If package uses many different
file extensions, a custom <code>CYGWIN-PATCHES/diff.sh</code> program can be used to
produce correct differences. The custom program is called with three
arguments:</p>
<pre>
    1. Original package root directory
    2. Modified package root directory
    3. Output file (will be under CYGWIN-PATCHES/.sinst/)</pre>
<p>Program should not change any of these parameters, but only adjust only
<code>diff(1)</code> options. Program must return standard shell status 0 on success
and non-zero on failure.</p>
<p>An example is presented below. For GNU <code>diff(1)</code>, don't forget to add the
final <code>[ &quot;$?&quot; = &quot;1&quot; ]</code> statement, which converts the GNU diff ok exit
status 1 to a standard shell ok exit status 0. GNU diff returns
unconventionally 1 on success and N &gt; 1 on error.</p>
<pre>
    #!/bin/sh
    # CYGWIN-PATCHES/diff.sh -- custom diff</pre>
<pre>
    diff -urN $1 $2             \
            --exclude='.build'  \
            --exclude='.inst'   \
            --exclude='.sinst'  \
            --exclude='*.o'     \
            --exclude='*.a'     \
            --exclude='*.dll'   \
            --exclude='*.exe'   \
            --exclude='*.bak'   \
            --exclude='*.tmp'   \
            --exclude='*~'      \
            --exclude='*#'      \
            --exclude='.#*'     \
            --exclude='.hg'     \
            --exclude='.bzr'    \
            --exclude='.git'    \
            --exclude='CVS'     \
            --exclude='RCS'     \
             ...[your options here]...\
    &gt; $3</pre>
<pre>
    [ &quot;$?&quot; = &quot;1&quot; ]
    # End of file</pre>
</dd>
<dt><strong><a name="dirs" class="item"><strong>dirs</strong></a></strong></dt>

<dd>
<p>If this file exists, directories mentioned in this file will be
created in <code>.inst/</code> directory prior running any other install
commands. Entries must not start with a leading slash. Comments are
ignored. An example:</p>
<pre>
    # Create empty directory for log files
    var/log/package</pre>
</dd>
<dt><strong><a name="install_lst" class="item"><strong>install.lst</strong></a></strong></dt>

<dd>
<p>NOTE: if file exists, the <code>make install</code> target is not run. See
also <a href="#delete_lst"><code>delete.lst</code></a>.</p>
<p>List <a href="#install"><code>install(1)</code></a> compatible entries in separate lines. The
format is:</p>
<pre>
    &lt;source&gt; [&lt;destination&gt; [&lt;mode, defaults to 644&gt;]]
    ln &lt;source&gt; &lt;destination&gt;
    mkdir &lt;source&gt;</pre>
<p>For the <em>src</em> part CYGWIN-PATCHES/{doc,conf} components are removed.
In addition all components of <em>destination</em> is also removed. This
allows making suitable &quot;mirrors&quot; of configuration directories unser
<code>CYGWIN-PATCHES</code>. Here, first the prefix component underlined is
removed, then the matchinf <em>destination</em> component from the left:</p>
<pre>
    CYGWIN-PATCHES/conf/etc/cron.d/program etc/cron.d/ 644
    ===================+++++++++++         +++++++++++</pre>
<p>The end result being:</p>
<pre>
    install -m 644 CYGWIN-PATCHES/conf/etc/cron.d/program .inst/etc/cron.d/</pre>
<p>If <em>destination</em> contains a trailing slash, the <em>src</em> is installed
to that directory. If there is no trailing slash, the last element is
used for filename. The third parameter is optional <em>mode</em> argument
passed to <code>install -m MODE</code>.</p>
<p>In <em>destination</em> part, expansion variables available are: <code>$PKG</code> for
package name, <code>$VER</code> for version number and <code>$DOC</code> for package
specific documentation directory. Notice that the <em>destination</em> must
not be an absolute path but a relative one under <em>.inst/</em> directory.
Common script suffixes like <code>.sh .pl .py</code> from <em>src</em> part are
removed when copying the file to <em>destination</em>. For commonly known
files, like <code>.sh .pl .py</code>, text files and manual pages that end to a
number, the <em>destination</em> is not needed. See exampels below.</p>
<p>If the first word is <code>ln</code>, then the 2nd word is the <em>source</em>
location of already installed program from previous lines. The 3rd
word is the <em>destination</em> name where the symlink is drawn. An
example:</p>
<p>If the first word is <code>mkdir</code>, then the 2nd word &lt;source&gt; is directory
name to create. Directories must start without leading slash and end
to a slash.</p>
<p>Empty lines and comments starting with &quot;#&quot; are ignored.</p>
<p>Examples:</p>
<pre>
    program usr/bin/            # install to /usr/bin/program, mode 755
    program usr/bin/new         # install to /usr/bin/new, mode 755
    prg.pl usr/bin/             # install to /usr/bin/prg, mode 755
    util usr/share/lib/$PKG/    # $PKG is the name of package
    util/program usr/share/doc/$PKG-$VER/contrib/
    this.doc $DOC/              # install under /usr/share/doc/&lt;program&gt;/
    CYGWIN-PATCHES/conf/cron.d/program  etc/cron.d/</pre>
<pre>
    # For some known files the &lt;dest&gt; is not needed.</pre>
<pre>
    prg.pl                      # install *.pl to /usr/bin/prg, mode 755
    prg.py                      # install *.py to /usr/bin/prg, mode 755
    manual.txt                  # install *.txt to /usr/share/doc/&lt;package&gt;/, mode 644
    man.1                       # install *.[1-9] under /usr/share/man/manN/, mode 644</pre>
<pre>
    lib/*.jar usr/share/lib/$PKG/ # install all JARs to library directory</pre>
<pre>
    # Create log directory
    mkdir var/log/package/</pre>
<pre>
    # Install a program
    program usr/bin/
    # Draw a symbolic link to it
    ln usr/bin/program aliasname</pre>
</dd>
<dt><strong><a name="install_sh" class="item"><strong>install.sh</strong></a></strong></dt>

<dd>
<p>This script is for binary packaging commands <strong>[package]</strong> and
<strong>[package-devel]</strong>.</p>
<p>If a Makefile (run by <code>make install</code>) includes hard coded paths or uses
<code>cp(1)</code> to copy files, to absolute locations, a custom installation procedure
may be needed. It would also help if the author of the original package were
contacted and suggested that a possible new releases of package would lean
to use <a href="#install"><code>install(1)</code></a> and Makefile variables. Those could be set externally and
controllable manner.</p>
<p>Examine the Makefile and its installation rules and write a script to mimic
same steps. When custom script is called:</p>
<pre>
  1. chdir has been done to source root package-N.N/
  2. it receives one argument: relative root of
     installation directory .inst/</pre>
<p>Be careful and double check the file locations after your custom install.sh
has been run:</p>
<pre>
  cd package-N.N/
  find .inst/ -print      &lt;&lt; print directory structure</pre>
<p>When the final binary package is installed by some user, it must not
unintentionally overwrite anything that is already in the system.</p>
<p><strong>NOTE:</strong> Instead of this file, it would be much better to gets hands dirty
and modify directly the original <code>Makefile</code>. Even if that meant writing
the whole installation from scratch. Copy install example from template
file <code>CYGWIN-PATCHES/Makefile.tmp</code>.</p>
</dd>
<dt><strong><a name="install_after_sh" class="item"><strong>install-after.sh</strong></a></strong></dt>

<dd>
<p>This script is for binary packages commands <strong>[package]</strong> and
<strong>[package-devel]</strong>. If this script exists, it is called after
cygbuild has run it's standard installation steps.</p>
<p>Sometimes there is no need to write full custom <a href="#install_sh"><code>install.sh</code></a>, but only
combine efforts of packages standard command &quot;make install&quot; with a little
cleanup afterward. For example, suppose that after packages &quot;make install&quot;
the directory structure would look like this (listing has been condensed):</p>
<pre>
    /tmp/build/package-1.13$ find .inst/ -print
    .inst/
    .inst/usr
    .inst/usr/share/doc
    .inst/usr/share/doc/package-1.13
    .inst/usr/share/doc/package-1.13/AUTHORS
    .inst/usr/share/doc/package-1.13/BUGS
    .inst/usr/share/doc/package-1.13/INSTALL
    .inst/usr/share/doc/package-1.13/NEWS
    .inst/usr/share/doc/Cygwin
    .inst/usr/share/doc/Cygwin/package-1.13.README
    .inst/usr/lib
    .inst/usr/lib/libpackage.la
    .inst/usr/lib/libpackage.a
    .inst/usr/lib/pkgconfig
    .inst/usr/lib/pkgconfig/package.pc
    .inst/usr/include
    .inst/usr/include/package
    .inst/usr/include/package/ne_request.h
    .inst/usr/bin
    .inst/usr/bin/package-config
    .inst/usr/share
    .inst/usr/share/man/man3
    .inst/usr/share/man/man3/ne_add_request_header.3
    .inst/usr/share/man/man3/ne_addr_destroy.3
    .inst/usr/share/man/man1
    .inst/usr/share/man/man1/package-config.1
    .inst/usr/share/doc
    .inst/usr/share/doc/package-1.13
    .inst/usr/share/doc/package-1.13/html
    .inst/usr/share/doc/package-1.13/html/apas01.html</pre>
<p>Does everything look good? No. Documentation appears to be installed twice.
In this case it is due to fact that cybuild.sh always runs it's own default
install for files under package's <code>doc/</code> directory. But if run &quot;make
install&quot; also does the same, it's a problem as in this case. The target
directory was just a little different. The documentation must appear in
directory <code>usr/share/doc/</code> and not <code>usr/doc/</code> over, so the
<a href="#install_after_sh"><code>install-after.sh</code></a> script's work is to remove the extra files:</p>
<pre>
    #!/bin/sh</pre>
<pre>
    rm -rf .inst/usr/doc</pre>
<pre>
    # End of file</pre>
</dd>
<dt><strong><a name="install_env_options" class="item"><strong>install.env.options</strong></a></strong></dt>

<dd>
<p>The <strong>[install]</strong> csommand runs series of install phases. After all the
Cygwin documentation is copied to directory <code>/usr/share/doc/package-1.12</code>, the
standard <code>make install</code> phase is run. If you need to set any environment
variables or arrange other things, do it in this file. It will be called
like</p>
<pre>
    source install.env.options</pre>
<p>If you need exotic 'make install' options, this is the place to configure.
For example, if <code>Makefile</code> does not use <em>DESTDIR</em> option, but a variable
<em>INSTALLROOT</em>, you can add that to 'make install' by defining generic
<code>CYGBUILD_MAKEFLAGS</code> make option. This works, because variables
<code>$instdir</code> and <code>$PREFIX</code> are set in the program and contain the needed
information.</p>
<pre>
    # Start of CYGWIN-PATCHES/install.env.options
    CYGBUILD_MAKEFLAGS=&quot;INSTALLROOT=$instdir$PREFIX&quot;
    # End of file</pre>
</dd>
<dt><strong><a name="install_tar_options" class="item"><strong>install.tar.options</strong></a></strong></dt>

<dd>
<p>The <strong>[install]</strong> command runs series of install phases. In the first, The
Cygwin documentation for package directory <code>/usr/share/doc/package</code> is
populated from files in the original package. Those of INSTALL, COPYRIGHT
and README are copied. Then any <code>doc/</code> directory if it exists. The
default rules exclude the most common files MANIFEST, *.bak, *.rej etc. and
version control subdirectories.</p>
<p>In this file it is possible to supply extra tar options to exclude more
files not to be included. Perhaps package's <code>doc/</code> directory contains
subdirectories that are targeted to software developers porting the
software etc. The format of file is presented below. Empty lines are
ignored. Comments must be placed in separate lines.</p>
<pre>
    # install.tar.options -- exclude these files from documentation</pre>
<pre>
    --exclude=*RISC*
    --exclude=*README.vms</pre>
<pre>
    #  Include files
    --include=notes.txt</pre>
<pre>
    # End of file</pre>
<p>If following option is defined, the automatic detection of possible
documentation directory is suppressed. Standard options like
<strong>--include=dir</strong> are still obeyed.</p>
<pre>
    --exclude=cygbuild-no-docdir-guess</pre>
<p>If following option is defined, only standard COPYING, TODO etc. files
found from top-level source directory are installed. No other
directories.</p>
<pre>
    --exclude=cygbuild-no-docdir-install</pre>
</dd>
<dt><strong><a name="mandir" class="item"><strong>mandir</strong></a></strong></dt>

<dd>
<p>If this file exists, it must contain only one line: the directory name
relative to CYGWIN-PATCHES where the manual pages are stored. An
example (which is also the default location):</p>
<pre>
   $ cat CYGWIN-PATCHES/mandir
   man</pre>
<p>This instructs to read manual pages from subdirectory
<code>CYGWIN-PATCHES/man</code> instead of root of <code>CYGWIN-PATCHES/</code>.</p>
</dd>
<dt><strong><a name="manpages" class="item"><strong>manpages</strong></a></strong></dt>

<dd>
<p>If this file exists, it lists upstream files that are to be considered
manual pages. The line syntax is one of:</p>
<pre>
    &lt;glob&gt;
    &lt;filename&gt;  [&lt;section&gt;] [&lt;destination file name&gt;]
    &lt;filename&gt;  usr/share/man/&lt;locale&gt;/&lt;section&gt;/&lt;destination file name&gt;</pre>
<p>The first word is a file name or a glob and second optional argument
is manual page section. If file name ends to <code>*.[1-8]</code>, it is used
for manual page section. Empty lines and comments on their own line
starting with <code>#</code> are ignored.</p>
<p>Examples:</p>
<pre>
   # With filename glob, other specifications in line are not allowd
   man/*.1
   # Install page &quot;program.man&quot; as usr/share/man/man1/program.1
   doc/program.man 1
   # Install page &quot;program.man&quot; as usr/share/man/man1/renamed.1
   doc/program.man 1 renamed.1
   # Install locale based manual page
   doc/program.1.fr usr/share/man/fr/man1/program.1</pre>
<p><em>Note:</em> this file is different from <a href="#install_lst"><code>install.lst</code></a> which also could
be used to install manual pages. The <a href="#manpages"><code>manpages</code></a> file is ran after
the standard 'make install' to accompany it whereas the <a href="#install_lst"><code>install.lst</code></a>
complaetely replaces the 'make install' call.</p>
</dd>
<dt><strong><a name="manualpage_1_pod" class="item"><strong>manualpage.1.pod</strong></a></strong></dt>

<dd>
<p>In case package does not include manual page or pages for certain
binaries, this file can be used as a template for manual pages. The
format is Perl's plain old documentation (pod) and the file itself is
self explanatory. Just fill in the text and rename the file according
to binaries that are documented. The page number is automatically read
from file name:</p>
<pre>
       X11 programs use section &quot;x&quot;
                                  |
   cp manualpage.1.pod  xprogram.1x.pod
   cp manualpage.1.pod  program.8.pod
      |                 |
      Template file     copy to &lt;program&gt;.&lt;section&gt;.pod</pre>
<p>The typical sections are:</p>
<pre>
   1  Normal binaries
   5  Configuration files
   8  Administrative binaries: /sbin</pre>
<p>Here are some markup help to use in <code>*.pod</code> files. See more
information by running <code>perldoc perlpod</code> or visit
<a href="http://perldoc.perl.org/perlpod.html">http://perldoc.perl.org/perlpod.html</a></p>
<pre>
  B&lt;bold text&gt;
  I&lt;italics&gt;
  C&lt;/some/file/name.here&gt;</pre>
<p>The <em>*.pod</em> files can be put to separate directory
<code>CYGWIN-PATCHES/man</code>.</p>
</dd>
<dt><strong><a name="mime" class="item"><strong>mime</strong></a></strong></dt>

<dd>
<p>If this file exists, it contains definitions according to <code>mailcap(1)</code>
that make use of the instaled programs. The contents of this file will
be installed in <code>/usr/lib/mime/packages/PACKAGE</code> directory.</p>
<p>An example entry for package catdoc:</p>
<pre>
  application/msword; catdoc %s; copiousoutput; description=MS Doc Text;</pre>
</dd>
<dt><strong><a name="package_bin_sh" class="item"><strong>package-bin.sh</strong></a></strong></dt>

<dd>
<p>If a single standard binary packaging command <strong>[package]</strong> or library
packaging command <strong>[package-devel]</strong> methods are not suitable, it is
possible to write a custom script. There may be need for separating files
into different tar.xz files etc. When custom script is called:</p>
<pre>
  1. chdir has been done to installation directory
     CYGWIN-PATCHES/.inst/</pre>
<pre>
  2. script receives 4 arguments:
     PACKAGE VERSION RELEASE TOPDIR</pre>
<p>The <code>TOPDIR</code> is the location where the script should place the <em>tar.xz</em>
files. It is typically directory above the sources: package-N.N/..</p>
</dd>
<dt><strong><a name="package_source_sh" class="item"><strong>package-source.sh</strong></a></strong></dt>

<dd>
<p>A custom script for making source packages. The call syntax and behavior is
same as <a href="#package_bin_sh"><code>package-bin.sh</code></a> explained above.</p>
</dd>
<dt><strong><a name="postinstall_sh" class="item"><strong>postinstall.sh</strong></a></strong></dt>

<dd>
<p>This file is for command <strong>[package]</strong>, which makes binary packages. The
<a href="#postinstall_sh"><code>postinstall.sh</code></a> is run when user installs Cygwin Net release package in
his system. Here you can clean, move or copy files, check environment and
do other things as needed. Postinstall scripts should assume that <code>PATH</code>
is <em>unset</em>, and all executables should be explicitly specified or the
patch must be set explicitly in script.</p>
</dd>
<dt><strong><a name="prepare_sh" class="item"><strong>prepare.sh</strong></a></strong></dt>

<dd>
<p>A custom script to run when package is prepared. Commands <strong>[all]</strong> and
<strong>[prepare]</strong> run the script. The purpose is to arrange everything to
be ready for the <strong>[configure]</strong> and <strong>[make]</strong> commands.</p>
<p>Normally command <strong>[clean]</strong> would be run along with the standard
preparations. The purpose of the clean is to make sure the source package
did not mistakenly include compiled files. If it did, that would later
prevent 'make' command to do nothing. Doing clean, makes it all pristine.</p>
</dd>
<dt><strong><a name="preremove_sh" class="item"><strong>preremove.sh</strong></a></strong></dt>

<dd>
<p>Copy this file as <code>.inst/etc/preremove/package.sh</code>. It will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version).</p>
</dd>
<dt><strong><a name="preremove_manifest_lst" class="item"><strong>preremove-manifest.lst</strong></a></strong></dt>

<dd>
<p>If <em>postinstall.sh</em> file copies any default setup files to <code>/etc</code>
directory, the absolute path names of files (one or many) must be listed
here. See topic <em>CYGWIN PACKAGE POLICY NOTES::Using preremove.sh and
postinstall.sh for upgrading /etc files</em>.</p>
</dd>
<dt><strong><a name="preremove_manifest_from_lst" class="item"><strong>preremove-manifest-from.lst</strong></a></strong></dt>

<dd>
<p>This file is used by <em>preremove.sh</em>. Contains <strong>list</strong> original
configuration files that are copied to locations mentioned in
<em>preremove-manifest.lst</em> file. A special tag <code>#PKGDOCDIR</code> can be used to
refer to the latest installed directory of
<code>/usr/share/doc/package-version</code>.</p>
<p>An example. Content of <a href="#preremove_manifest_lst"><code>preremove-manifest.lst</code></a> lists the target file that
contains the site wide setup:</p>
<pre>
    /etc/package.conf</pre>
<p>The previous version of package <a href="#package"><code>package</code></a> has put documentation in directories:</p>
<pre>
    ...
    /usr/share/doc/package-1.2
    /usr/share/doc/package-1.3
    /usr/share/doc/package-1.4</pre>
<p>so the site wide configuration file could had come from the last
directory. Let's suppose upstream has put the example in:</p>
<pre>
    /usr/share/doc/package-1.4/examples/package.conf</pre>
<p>When new version of package is about to be installed by <em>setup.exe</em>, the
<em>preremove.sh</em> script can examine if the system wide setup file(s) pointed
by <a href="#preremove_manifest_lst"><code>preremove-manifest.lst</code></a> hasn't been changed from the package's
upstream examples listed in &lt;preremove-manifest-from.lst&gt; which now can
simply read:</p>
<pre>
    $PKGDOCDIR/examples/package.conf</pre>
<p>The special tag <code>#PKGDOCDIR</code> is just a shorthand pointer to the latest
documentation directory. If these two files do not differ, the
&lt;preremove.sh&gt; can safely delete <code>/etc/package.conf</code> and let the
<a href="#postinstall_sh"><code>postinstall.sh</code></a> to install new file from upstream source that is
mentioned in &lt;preremove-manifest-from.lst&gt;. This effectively means:</p>
<pre>
    preremove: if files listed in C&lt;preremove-manifest.lst&gt;
       have not been changed, remove them.</pre>
<pre>
    postinstall: if there are no files that are listed in
        C&lt;preremove-manifest.lst&gt; file then install new upstream files
        pointed by &lt;preremove-manifest-from.lst&gt;</pre>
</dd>
<dt><strong><a name="publish_sh" class="item"><strong>publish.sh</strong></a></strong></dt>

<dd>
<p>A custom script to publish package.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="managing_a_build_tree">MANAGING A BUILD TREE</a></h1>
<p>
</p>
<h2><a name="how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></h2>
<p>If you intend to port many packages to Cygwin, a good directory structure
helps keeping things organized. Suppose you have 3 packages (package, bar,
quux) of which 2 have been updated twice (there has been two ported
releases):</p>
<pre>
    ROOT/           ( /usr/src/cygwin-build )
    |
    +--package/     ( /usr/src/cygwin-build/package )
    |  +--package-1.3/
    |  +--package-1.4/
    |  |
    |  package-1.3.tar.gz
    |  package-1.3-1.tar.xz
    |  package-1.3-1-src.tar.xz
    |  |
    |  package-1.4.tar.gz
    |  package-1.4-1.tar.xz
    |  package-1.4-1-src.tar.xz
    |
    +--bar/
    |  +--bar-3.12/
    |  +--bar-3.17/
    |  |
    |  bar-3.12.tar.gz
    |  bar-3.12-1.tar.xz
    |  bar-3.12-1-src.tar.xz
    |  |
    |  bar-3.17.tar.gz
    |  bar-3.17-1.tar.xz
    |  bar-3.17-1-src.tar.xz
    |
    +--quux/
       +--quux-2.2/
       |
       quux-2.2.tar.gz
       quux-2.2-1.tar.xz
       quux-2.2-1-src.tar.xz</pre>
<p>At first sight this may look complex, but with this structure you can
manage several packages easily. For each package, reserve a separate
directory where you do your work: <a href="#package"><code>package/</code></a>, <code>bar/</code>, <code>quux/</code> etc. Download
original packages to these directories and unpack the sources. Let's examine
package <a href="#package"><code>package</code></a></p>
<pre>
    cd /usr/src/cygwin-build/package
    wget &lt;URL&gt;/package-1.4.tar.gz</pre>
<p>After unpack, you should see a clean directory name:</p>
<pre>
    tar zxvf package-1.4.tar.gz
       ...
       package-1.4/</pre>
<p>Sometimes the packages unpacks to an uncommon directory:</p>
<pre>
    package1.4b/</pre>
<p>Use previously recommended symlink approach to convert the name into more
standard form. Here the 'b' is minor release '2':</p>
<pre>
    ln -s package1.4b/ package-1.4.2/</pre>
<p>There isn't much to do after that. You do your builds in the unpack
directories as usual. Supposing this is &quot;standard&quot; looking GNU package
which includes a <a href="#configure"><code>./configure</code></a>, making a Net release should be as simple
as running:</p>
<pre>
    cd package-1.4/
    cygbuild files</pre>
<pre>
    ..  Now edit files in CYGWIN-PATCHES/</pre>
<pre>
    cygbuild configure make install</pre>
<pre>
    .. Verify install results</pre>
<pre>
    find .inst/</pre>
<pre>
    .. If all look okay, make binary and source Net releases</pre>
<pre>
    cygbuild -r 1 install package readmefix install package source-package</pre>
<p>With these commands, Cygwin Net release packages are copied one directory
up to the same place where the original compresses source kit is:</p>
<pre>
    /usr/src/cygwin-build/package/package-1.4-1.tar.xz
    /usr/src/cygwin-build/package/package-1.4-1-src.tar.xz</pre>
<p>If you have a web server that can serve the package, copy the files to
publish area with command:</p>
<pre>
    package-1.4$ cygbuild publish</pre>
<p>
</p>
<h2><a name="rebuilding_packages">Rebuilding packages</a></h2>
<p>NOTE: This section is highly experimental and the program has not yet been
tested well. (FIXME)</p>
<p>As Cygwin is improved, the main library file <code>cygwin1.dll</code> may change and
periodically all packages must be rebuilt so that they link to the latest
function calls. In this case you have to rebuild every package you
maintain. Instead of going to every directory and typing the relevant
&quot;cygbuild clean conf make install ..&quot;, there is a helper script that
automates the task. If you use the standard build layout as described in
previous topic, you can use rebuild script to do the steps. Is is also a
good chance to verify that the package build process is repeatable:</p>
<pre>
    cygbuild-rebuild.sh -d /usr/src/cygwin-build -i 1 2&gt;&amp;1 | tee build.log
                         |                       |
                         |                       increase releases by 1
                         |
                         directory where to start recursive build</pre>
<p>If something goes wrong, you have to manually fix the package. Do not run
the rebuild script again until you have fixed the build process for a
broken package.</p>
<p>
</p>
<hr />
<h1><a name="library_usage">LIBRARY USAGE</a></h1>
<p>In addition to <em>cygbuild</em> being a builder program, it can be used as a
library that can be sourced to any bash program. This makes it possible to
selectively use functions from it. The library feature is enabled by setting
variable <code>CYGBUILD_LIB</code> before <code>source</code> command. When invoked this way,
the <em>cygbuild's</em> <code>Main()</code> function in not invoked and options or
commands are bypassed.</p>
<p><strong>WARNING:</strong> While the functions are name space clean and contain
prefix <strong>Cygbuild*</strong>, many global variables are defined that do not
include this prefix. These variables include <code>$instdir</code>, <code>$builddir</code>
etc.</p>
<p>To get access to full power of the functions, these steps are needed:</p>
<pre>
    #!/bin/sh</pre>
<pre>
    CYGBUILD=$(which cygbuild)</pre>
<pre>
    #   Load &quot;as library&quot;</pre>
<pre>
    CYGBUILD_LIB=1 source $CYGBUILD</pre>
<pre>
    #   Provided that the current directory's PWD is inside
    #   some/path/package-1.13. If not, then please skip this part
    #   completely.</pre>
<pre>
    local tdir=$(pwd)
    local -a array=( $(CygbuildSrcDirLocation $tdir) )
    local top=${array[0]}
    local src=${array[1]}</pre>
<pre>
    CygbuildDefineGlobalMain    \
        &quot;$top&quot;                  \
        &quot;$src&quot;                  \
        &quot;$RELEASE&quot;              \</pre>
<pre>
    #   Now any function can be called. Like installing documentation</pre>
<pre>
    CygbuildInstallPackageDocs
    CygbuildInstallCygwinPart</pre>
<pre>
    #   End of example</pre>
<p>
</p>
<hr />
<h1><a name="cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></h1>
<p>
</p>
<h2><a name="using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></h2>
<p>The <code>/etc</code> directory is meant for configuration files for programs. The first
installation typically copies the package's default setup file there but
subsequent installations won't overwrite existing files in order to
preserve user's modifications. If new version of the package includes new
features, those are not found from the &quot;old&quot; <code>/etc</code> configuration files.</p>
<p>Let's suppose user has not yet modified system wide configuration file
<code>/etc/package.conf</code> and package includes newer one in
<code>/usr/share/doc/package-1.2/package.conf.example</code>. In this case the installation
should copy the new example file over <code>/etc/package.conf</code> to reflect possible
new features in the program.</p>
<p>The trick is to include a <em>preremove.sh</em> script in the Cygwin Net Release
binary package. A file named <code>/etc/preremove/package.sh</code> will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version), so in that script, if
<code>/etc/package.conf</code> exists and is identical to
<code>/usr/share/doc/package.conf.example</code>, the <em>preremove.sh</em> should delete it
and let <em>postinstall.sh</em> install new one. If the <code>/etc/package.conf</code> is
modified, it must be left alone.</p>
<p>Also, it is a good idea to have a file <code>/etc/preremove/package-manifest.lst</code>,
which lists every file that was created by the <em>postinstall.sh</em> script,
and which will be removed on <em>preremove.sh</em> if untouched by the user.
Someday, <code>cygcheck -c</code> might parse the manifest lists to help diagnose if
postinstall has not completed.</p>
<p>
</p>
<h2><a name="music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></h2>
<p>It is allowed to include any music related code if MP3 related code is not
compiled in (cf.
 <a href="http://permalink.gmane.org/gmane.os.cygwin.applications/11360">http://permalink.gmane.org/gmane.os.cygwin.applications/11360</a> )</p>
<p>As long as Cygwin is released on US based server, the general rules
are that it is permissible to include and not include in Cygwin are
basically the same as for the Fedora project. See
<a href="http://fedoraproject.org/wiki/ForbiddenItems">http://fedoraproject.org/wiki/ForbiddenItems</a> which reads:</p>
<pre>
  * If it is proprietary, it cannot be included in Cygwin.
  * If it is legally encumbered, it cannot be included in Cygwin.
  * If it violates US Federal law, it cannot be included in Cygwin.</pre>
<p>This is different from SUSE and Debian. SUSE is located in another
country may even pay royalties. Debian has a different legal point of
view than Red Hat See
<a href="http://lists.debian.org/debian-legal/2005/07/msg00081.html">http://lists.debian.org/debian-legal/2005/07/msg00081.html</a> for more
information. Due to Cygwin's presence on a Red Hat server, the project
is bound to Red Hat rules.</p>
<p>
</p>
<hr />
<h1><a name="troubleshooting">TROUBLESHOOTING</a></h1>
<p>
</p>
<h2><a name="porting_and_python_os_rename">Porting and Python os.rename</a></h2>
<p>NOTE: This may not be relevant as of 2012 any more. If python application
contains calls to <em>os.rename(from, to)</em> or <em>osutils.rename(from,
to)</em>, older Python released have causes unlock race condition under
Cygwin.</p>
<pre>
  OSError: [Errno 13] Permission denied</pre>
<p>Please contact the upstream to negotiate how to solve this. One possible
solution is to rewrite all calls to:</p>
<pre>
    import os, shutil</pre>
<pre>
    def saferename(a, b):
        shutil.copy2(a, b)
        os.unlink(a)</pre>
<p>
</p>
<h2><a name="general_errors">General errors</a></h2>
<p>Make always sure that you work inside well formed source directory
<code>package-VERSION/</code>, like <code>package-1.13/</code>. If you issue command anywhere
else, the program does not know where it is.</p>
<p>
</p>
<h2><a name="problem_with_command__all_">Problem with command [all]</a></h2>
<p>If you get an error, make sure that you have a clean build directory.
Nothing else other than:</p>
<pre>
    1. a source file
    2. a possible patch to make package work under Cygwin</pre>
<p>The <strong>[all]</strong> is special and it should not be run only for testing already
packages Cygwin Net Releases. It unpacks and patches the source package. If
any other commands are run patch may be tried to apply second time which
naturally fails and script execution stops. Something like</p>
<pre>
    The next patch would create the file ...
    which already exists!  Skipping patch.
    1 out of 1 hunk ignored -- saving rejects to file ...
    [FATAL] status is 1.</pre>
<p>Start all from fresh. Remove unpack directory <code>rm -rf package-N.N/</code> and
repeat command <strong>[all]</strong>.</p>
<p>
</p>
<h2><a name="command__check__cannot_find_files">Command [check] cannot find files</a></h2>
<p>The full error reads something like this:</p>
<pre>
    cygbuild.pl.CygcheckDepsCheckMain: Nothing to do, no *.exe *.dll found in /usr/src/build/package/package-5.07/.inst</pre>
<p>Command <strong>[check]</strong> was ran, but commands <strong>[conf]</strong> <strong>[make]</strong> and
<strong>[install]</strong> were not. The <strong>[install]</strong> phase copies files under <code>.inst/</code>
directory where the <strong>[check]</strong> command expects them.</p>
<p>
</p>
<h2><a name="problem_with_command__install_">Problem with command [install]</a></h2>
<p>Following error is displayed:</p>
<pre>
    $ cygbuild -v -r 1 package</pre>
<pre>
    [ERROR] no package-0.5/.inst/usr/share/doc/Cygwin.
    Did forget to run 'files' before 'install'?</pre>
<p>The check did not find anything inside
<code>.inst/usr/share/doc/Cygwin</code> which is mandatory directory for Cygwin
binary packages. Check that directory <code>package-N.N/CYGWIN-PATCHES/</code>
includes files <code>package.README</code> and <code>setup.hint</code>. These files can be
initially created with command <strong>[files]</strong>.</p>
<p>
</p>
<h2><a name="command__package__displays_warnings">Command [package] displays warnings</a></h2>
<p>Following warning while making a binary package is displayed:</p>
<pre>
    -- Wait, reading and preparing variables based on current directory
    -- Hm, no *.exe or *.dll files, skipping strip.
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:1:&lt;PKG&gt;
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:24:  unpack &lt;PKG&gt;-VER-REL-src.tar.xz</pre>
<p>The warning means, that file <code>CYGWIN-PATCHES/package.README</code> looked
like a template. Edit <code>package.README</code> file and leave all &lt;PKG&gt;, &lt;VER&gt;
and &lt;REL&gt; tags alone. Then run command <strong>[readmefix]</strong> which will substitute
proper values for these tags.</p>
<p>
</p>
<h2><a name="while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></h2>
<p>Program uses predefined set of ignore rules to exclude binary files
from the difference comparison. There is always a possibility that the
package you compiled generated binary files that are unknown. In those
cases, examine the diff output carefully hinted by message:</p>
<pre>
    [ERROR] Making a patch failed, check /usr/src/package-N.N/.sinst/package-*.patch</pre>
<p>Run following command to determine the problematic files in the
<code>diff(1)</code> listing:</p>
<pre>
    egrep -n -i 'files.*differ' /usr/src/package-N.N/.sinst/package-*.patch</pre>
<p>Add problematic file patterns file <em class="file">CYGWIN-PATCHES/diff.options</em> or
in difficult cases write custom <code>CYGWIN-PATCHES/diff.sh</code> script. See
section &quot;Optional external scripts&quot; for more information.</p>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<p>Default values for command <strong>[install]</strong>:</p>
<pre>
    CYGBUILD_INSTALL=/usr/bin/install
    CYGBUILD_INSTALL_DATA=&quot;-m 644&quot;
    CYGBUILD_INSTALL_BIN=&quot;-m 755&quot;</pre>
<p>Default values for command <strong>[publish]</strong>:</p>
<pre>
    CYGBUILD_PUBLISH_DIR=/usr/src/cygwin-packages
    CYGBUILD_PUBLISH_BIN=</pre>
<p>Default values for command <strong>[readmefix]</strong> are below. The lines below mean
that if <code>CYGBUILD_FULLNAME</code> is not set, the <code>NAME</code> is tried, and last Debian
<code>DEBFULLNAME</code> variable. See also option <strong>--email</strong>.</p>
<pre>
    CYGBUILD_FULLNAME || NAME
    CYGBUILD_EMAIL    || EMAIL</pre>
<p>Default values for command <strong>[cygsrc]</strong>. The value must point to
URL directory where Cygwin Net Release setup.ini file resides.</p>
<pre>
    CYGBUILD_SRCPKG_URL=<a href="http://mirror.switch.ch/ftp/mirror/cygwin">http://mirror.switch.ch/ftp/mirror/cygwin</a></pre>
<p>Temporary values can be given from /bin/bash prompt like this:</p>
<pre>
    bash$ EMAIL=me@example.org cygbuild [options] -r RELEASE &lt;commands&gt;</pre>
<p>
</p>
<hr />
<h1><a name="files">FILES</a></h1>
<p>Temporary files are created to <code>/tmp/cygbuild.tmp.*</code>. They are removed at
the end of program.</p>
<p>Command <strong>[files]</strong> creates template files under <code>./CYGWIN-PATCHES</code>.
Default templates are located in directory
<code>/usr/share/cygbuild/template</code>. Developer's own templates can
be placed in directory <code>/etc/cygbuild/template</code>. These overwrite those in
<code>/usr/share/cygbuild/template</code>.</p>
<p>
</p>
<hr />
<h1><a name="standards">STANDARDS</a></h1>
<p>Cygwin Package Contributor's Guide' at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> .
Remember to compile libraries using <strong>-Wl,--enable-auto-image-base</strong>
Cf. 2005-12-19 &lt;http://cygwin.com/ml/cygwin-apps/2005-12/msg00101.html&gt;.</p>
<p>A generic Bourne Shell build script can be found at page
<a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> and also available at</p>
<pre>
  cvs -d :pserver:anoncvs@sources.redhat.com:/cvs/cygwin-apps checkout packaging/templates</pre>
<p>Consult list of packages before intent to port [ITP]: See file
/etc/setup/installed.db or oage &lt;http://cygwin.com/packages/&gt;.</p>
<p>File system Hierarchy Standard at &lt;http://www.pathname.com/fhs/&gt;</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>
</p>
<h2><a name="commands_must_be_ordered">Commands must be ordered</a></h2>
<p>The application does not check the sanity of the command line
arguments. For example running commands in wrong order. It makes no
sense trying to make a binary <em>package</em> before the package has been
built or installed.</p>
<pre>
   cygbuild -r 1 package conf make install</pre>
<p>The commands are always executed in listed order.</p>
<p>
</p>
<h2><a name="other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></h2>
<p>This porting tool only handles <code>*.tar.gz</code>, <code>*.tar.bz2</code>,
<code>*.tar.lzma</code> and <code>*.tar.xz</code> archives. To port e.g. a <code>*.zip</code>
archive, you need to manually convert it to a recognized format:</p>
<pre>
    unzip package-N.N.zip
    ... convert source archive to *.tar.gz
    tar -cvf package-1.1.tar.gz package-N.N/
    ... Now proceed normally
    cd package-N.N/
    cygbuild -r 1 mkdirs files conf make install</pre>
<p>
</p>
<h2><a name="reporting_bugs">Reporting bugs</a></h2>
<p>If you run into a bug, activate debug mode and send complete output
listing to the maintainer. Provide also an URL link to the source
package that you tried to build.</p>
<pre>
    echo <a href="http://example.com/source">http://example.com/source</a>      &gt;  ~/tmp/error.log
    pwd; ls -la . ..                    &gt;&gt; ~/tmp/error.log
    bash -x cygbuild [options] CMD ...  &gt;&gt; ~/tmp/error.log 2&gt;&amp;1</pre>
<p>
</p>
<h2><a name="slow_program_startup">Slow program startup</a></h2>
<p>You may notice that the startup is a little slow. This is due to way
the program determining what many global variables need to be
available at runtime. The method of checking environment is not
particularly efficient (due to bash-scripting limitations in general).
E.g. same checks of version and release numbers are called multiple
times.</p>
<p>
</p>
<hr />
<h1><a name="miscellaneous">MISCELLANEOUS</a></h1>
<p>
</p>
<h2><a name="makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></h2>
<p>To compile libraries for Cygwin, the <code>LDFLAGS</code> should include option
<code>-no-undefined</code>. If there is <code>Makefile(.in|.am)</code>, after patching
them manually, you can regenerate the Makefiles with</p>
<pre>
    autoreconf --install --force --verbose</pre>
<p>
</p>
<h2><a name="yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></h2>
<p>Sometimes the <code>*.y</code> file won't compile. See thread &quot;ftpcmd.y --
syntax error&quot; at
&lt;http://lists.gnu.org/archive/html/help-bison/2004-04/msg00015.html&gt;.</p>
<pre>
    bison -y ftpcmd.y
    ftpcmd.y:185.17: syntax error, unexpected &quot;=&quot;</pre>
<pre>
    ...There are occurrences of &quot;&lt;tab&gt;=&lt;tab&gt;{&quot; in ftpcmd.y (in the
    wu-ftpd 2.6.2 source release). Changing all of these to &quot;&lt;tab&gt;{&quot;
    fixes the problem -- and doesn't cause problems for Berkeley yacc,
    or for earlier versions of bison.</pre>
<p>
</p>
<h2><a name="cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></h2>
<p>If program X's <a href="#postinstall"><code>postinstall</code></a> is doing a <code>cp</code>, it does not preserve the ACL
permissions. The <a href="#postinstall"><code>postinstall</code></a> script must be accompanied with <code>touch(1)</code>
to create the new file before copying unto it or a call to <code>chmod</code> to set
reasonable permissions after the copying. If that's not done, the user may
end up having unreadable files. NOTE: <code>cp -p</code> will not work, but <code>install
-m</code> would.
(Cf. &lt;http://cygwin.com/ml/cygwin-apps/2005-01/msg00148.html&gt;).</p>
<p>
</p>
<h2><a name="use_of_hard_links">Use of hard links</a></h2>
<p>Some ported packages may rely on hard links. Those are efficient only
under NTFS and not FAT. Please include note to &lt;package&gt;.README that
the utility may not be best under FAT file systems.</p>
<p>
</p>
<h2><a name="setup_hint_should_list_all_dependencies">setup.hint should list all dependencies</a></h2>
<p>The <em>requires:</em> line is not only an indication of what to pull in,
but also what the package actually uses. These dependences are also
used to find the order of postinstall scripts (so, if package has any
postinstall scripts with <code>#!/bin/sh</code>, the scripts may not work
because the bash postinstall script was not run). So include all
direct dependences in the <em>requires:</em> line, even if they are in
<strong>Base</strong> category.
(Cf. &lt;http://cygwin.com/ml/cygwin-apps/2008-03/msg00070.html&gt;).</p>
<p>
</p>
<hr />
<h1><a name="availability">AVAILABILITY</a></h1>
<p><a href="http://freecode.net/projects/cygbuild">http://freecode.net/projects/cygbuild</a></p>
<p>
</p>
<hr />
<h1><a name="osnames">OSNAMES</a></h1>
<p>Cygwin</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><code>cygport(1)</code>
<code>gpg(1)</code></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Copyright (C) 2003-2024 Jari Aalto. This program is free software; you
can redistribute and/or modify program under the terms of Gnu General
Public license v2 or, at your option, any later version.</p>

</body>

</html>
