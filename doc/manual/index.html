<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>cygbuild - Cygwin source and binary package build script</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:rurban@x-ray.at" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#quick_overview">QUICK OVERVIEW</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></li>
	<ul>

		<li><a href="#preparation_commands">Preparation commands</a></li>
		<li><a href="#build_commands">Build commands</a></li>
		<li><a href="#install_commands__in_order_of_execution_">Install commands (in order of execution)</a></li>
		<li><a href="#packaging_commands">Packaging commands</a></li>
		<li><a href="#digital_signature_commands">Digital signature commands</a></li>
		<li><a href="#patch_management_commands">Patch management commands</a></li>
		<li><a href="#other_commands">Other commands</a></li>
	</ul>

	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#packages_with_no_version_number">Packages with no version number</a></li>
		<li><a href="#packages_with_non_standard_versioning_schemes">Packages with non-standard versioning schemes</a></li>
		<li><a href="#packaging_directly_from_version_control_repositories">Packaging directly from version control repositories</a></li>
	</ul>

	<li><a href="#making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></li>
	<ul>

		<li><a href="#preliminary_setup">Preliminary setup</a></li>
		<li><a href="#now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></li>
		<li><a href="#contributing_packages">Contributing packages</a></li>
	</ul>

	<li><a href="#gpg_examples">GPG EXAMPLES</a></li>
	<li><a href="#optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></li>
	<li><a href="#optional_external_files">OPTIONAL EXTERNAL FILES</a></li>
	<li><a href="#managing_a_build_tree">MANAGING A BUILD TREE</a></li>
	<ul>

		<li><a href="#how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></li>
		<li><a href="#rebuilding_packages">Rebuilding packages</a></li>
	</ul>

	<li><a href="#library_usage">LIBRARY USAGE</a></li>
	<li><a href="#cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></li>
	<ul>

		<li><a href="#using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></li>
		<li><a href="#music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></li>
	</ul>

	<li><a href="#troubleshooting">TROUBLESHOOTING</a></li>
	<ul>

		<li><a href="#porting_and_python_os_rename">Porting and Python os.rename</a></li>
		<li><a href="#general_errors">General errors</a></li>
		<li><a href="#problem_with_command__all_">Problem with command [all]</a></li>
		<li><a href="#command__check__cannot_find_files">Command [check] cannot find files</a></li>
		<li><a href="#problem_with_command__install_">Problem with command [install]</a></li>
		<li><a href="#command__package__displays_warnings">Command [package] displays warnings</a></li>
		<li><a href="#while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></li>
	</ul>

	<li><a href="#environment">ENVIRONMENT</a></li>
	<li><a href="#files">FILES</a></li>
	<li><a href="#standards">STANDARDS</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<ul>

		<li><a href="#commands_must_be_ordered">Commands must be ordered</a></li>
		<li><a href="#other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></li>
		<li><a href="#reporting_bugs">Reporting bugs</a></li>
		<li><a href="#slow_program_startup">Slow program startup</a></li>
	</ul>

	<li><a href="#miscellaneous">MISCELLANEOUS</a></li>
	<ul>

		<li><a href="#makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></li>
		<li><a href="#yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></li>
		<li><a href="#cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></li>
		<li><a href="#use_of_hard_links">Use of hard links</a></li>
		<li><a href="#setup_hint_should_list_all_dependencies">setup.hint should list all dependencies</a></li>
	</ul>

	<li><a href="#availability">AVAILABILITY</a></li>
	<li><a href="#osnames">OSNAMES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>cygbuild - Cygwin source and binary package build script</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    cygbuild [options] [-r RELEASE] CMD [CMD ...]</pre>
<p>
</p>
<hr />
<h1><a name="quick_overview">QUICK OVERVIEW</a></h1>
<p>The directories used in the program are as follows:</p>
<pre>
  ROOT/package
       &lt;original upstream package source(s): package-1.2.3.tar.gz&gt;
       |
       +- package-1.2.3/
          &lt;upstream *.tar.gz unpacked&gt;
          &lt;All cygbuild commands must be given in *this* directory&gt;
          |
          +- .build/
          |  &lt;generic working area of temporary files&gt;
          |  |
          |  +- build/
          |  |  &lt;separate &quot;shadow&quot; directory where compiling happens&gt;
          |  |  &lt;contains only symlinks and object *.o etc. files&gt;
          |  |
          |  +- package-1.2.3-orig/
          |     &lt;Used during taking a diff for Cygwin source package&gt;
          |
          +- .inst/
          |  &lt;The &quot;make install&quot; target directory&gt;
          |
          +- .sinst/
              &lt;diffs, signatures, binary and source packages appear here&gt;</pre>
<p><strong>CASE A)</strong> to build Cygwin Net Release from a package that includes a
standard <a href="#configure"><code>./configure</code></a> script, the quick path for porting would be in
the fortunate case:</p>
<pre>
    $ export NAME=&quot;Firstname Lastname&quot;
    $ export EMAIL=&quot;foo@example.com&quot;</pre>
<pre>
    ... make a project directory</pre>
<pre>
    $ mkdir -p /tmp/package
    $ cd /tmp/package
    $ wget <a href="http://example.com/package-N.N.tar.gz">http://example.com/package-N.N.tar.gz</a>
    $ tar -zxvf package-N.N.tar.gz</pre>
<pre>
    ... source has now been unpacked, go there</pre>
<pre>
    $ cd package-N.N/</pre>
<pre>
    ... If this is the first port ever, it is better to run commands
    ... individually to see possible problems.
    ...
    ... If you have GPG key, you can add options -s &quot;SignerKeyID&quot;
    ... -p &quot;pass phrase&quot; to commands 'package', 'source-package' and
    ... 'publish'. Option -r marks &quot;release 1&quot;.</pre>
<pre>
    $ cygbuild -r 1 makedirs
    $ cygbuild -r 1 files
    $ cygbuild -r 1 readmefix       # Fill in CYGWIN/package.README
    $ cygbuild -r 1 shadow          # prepare sources to .build/build
    $ cygbuild -r 1 configure
    $ cygbuild -r 1 make
    $ cygbuild -r 1 -v -t install   # &quot;verbose test mode&quot; first
    $ cygbuild -r 1 install         # The &quot;real&quot; install
    $ find .inst/ -print            # Verify install structure
    $ cygbuild -r 1 -v check        # Do install integrity check
    $ cygbuild -r 1 package         # Make Net install binary
    $ cygbuild -r 1 source-package  # Make Net install source
    $ cygbuild -r 1 publish         # Copy files to publish area (if any)</pre>
<p>There is also shortcut 'import', which runs all steps up till 'make'</p>
<pre>
    $ cygbuild -r 1 import
    ...  Package is configured. Did it succeed? Run test install
    $ cygbuild -r 1 -v -t install
    ...  If ok, continue just like in the example above</pre>
<p>To make this easier, an alias will help.</p>
<pre>
    $ alias cb=&quot;cygbuild --color --sign $GPGKEY&quot;
    $ cb -r 1 import
    ...</pre>
<p><strong>CASE B)</strong> If the downloaded Cygwin source release package is
controlled by cygbuild, then commands <strong>[all]</strong> and <strong>[almostall]</strong> can
be used to check the binary build:</p>
<pre>
    $ mkdir -p /tmp/package
    $ cd /tmp/package
    $ tar -xf /path/to/package-N.N-RELEASE-src.tar.bz2
    $ ./*.sh --color --verbose all</pre>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<dl>
<dt><strong><a name="b_bzip2" class="item"><strong>-b|--bzip2</strong></a></strong></dt>

<dd>
<p>Use bzip2 compression instead of default package compression. This
affects the manual pages and the usr/share/doc/*/ content.</p>
</dd>
<dt><strong><a name="c_color" class="item"><strong>-c|--color</strong></a></strong></dt>

<dd>
<p>Activate colors in displayed messages.</p>
</dd>
<dt><strong><a name="cygbuiddir_dir" class="item"><strong>--cygbuiddir DIR</strong></a></strong></dt>

<dd>
<p>PATH where all the temporary files are kept; object files, taking diffs
etc. The default value is <a href="#build"><code>./.build</code></a>.</p>
</dd>
<dt><strong><a name="cyginstdir_dir" class="item"><strong>--cyginstdir DIR</strong></a></strong></dt>

<dd>
<p>PATH where <code>make install</code> will install the source package's executable
files, documentation files etc. The default value is <code>./.inst</code>.</p>
</dd>
<dt><strong><a name="cygsinstdir_dir" class="item"><strong>--cygsinstdir DIR</strong></a></strong></dt>

<dd>
<p>PATH where ready Cygwin Net Release packages and patch files are put.
etc. The default value is <code>./.sinst</code>.</p>
</dd>
<dt><strong><a name="d_debug_level" class="item"><strong>-d|--debug LEVEL</strong></a></strong></dt>

<dd>
<p>Turn on debug. Usually means running external shell files with -x
enabled.</p>
</dd>
<dt><strong><a name="e_email_email" class="item"><strong>-e|--email EMAIL</strong></a></strong></dt>

<dd>
<p>Set email address. This effectively sets variable <code>CYGBUILD_EMAIL</code>
that is used in <strong>[readmefix]</strong> command.</p>
</dd>
<dt><strong><a name="g_gbs" class="item"><strong>-g|--gbs</strong></a></strong></dt>

<dd>
<p>Activate g-b-s compatibility mode -- that is -- behave like Cygwin Build
Script. This changes behavior and command in the following manner:</p>
<dl>
<dt><strong><a name="commands_all_binary_package_and_source_package" class="item">commands: <strong>[all]</strong>, <strong>[binary-package]</strong> and <strong>[source-package]</strong></a></strong></dt>

<dd>
<p>Move the generated source package <code>package-N.N.tar.bz2</code> and binary package
<code>package-N.N-src.tar.bz2</code> to one directory up <code>../</code> instead the default
location &lt;./sinst&gt;.</p>
</dd>
</dl>
</dd>
<dt><strong><a name="f_file_file" class="item"><strong>-f|--file FILE</strong></a></strong></dt>

<dd>
<p>Specify package file and version, like <code>foo-1.11.tar.gz</code> from which the
VERSION and possible RELEASE numbers can be derived. This option is needed
only if the current directory is not in format <code>package-version</code>. Problems
in 99% of the cases are in the source file names. See 'Packages with
non-standard versioning schemes' how to deal with unusual packages when
doing porting.</p>
<p>This option comes handy with command <strong>[check]</strong> when someone else's
binary package results are being checked. An example:</p>
<pre>
  $ ls
    foo-2.1.tar.gz
    foo-2.1-1.tar.bz2
    foo-2.1-1-src.tar.bz2
  ... make &quot;pseudo&quot; install directory
  $ mkdir .inst
  ... examine the binary package
  $ (cd .inst ; tar -jxvf ../foo-2.1-1.tar.bz2)
  $ cygbuild -f foo-2.1-1.tar.bz2 --cyginstdir .inst --verbose check</pre>
</dd>
<dt><strong><a name="h" class="item"><strong>-h</strong></a></strong></dt>

<dd>
<p>Print program's internal short help.</p>
</dd>
<dt><strong><a name="help" class="item"><strong>--help</strong></a></strong></dt>

<dd>
<p>Print long help (this page).</p>
</dd>
<dt><strong><a name="install_prefix_prefix" class="item"><strong>--install-prefix PREFIX</strong></a></strong></dt>

<dd>
<p>Set custom install PREFIX. The value must be path (no leading slash)
relative to install dir <code>./.sinst</code>. The default is to install using prefix
value <em>usr</em>, which puts files in directories like:</p>
<pre>
    usr/bin
    usr/share/doc
    ...</pre>
</dd>
<dt><strong><a name="install_usrlocal" class="item"><strong>--install-usrlocal</strong></a></strong></dt>

<dd>
<p>Arrange all relevant prefixes to use <code>usr/local</code> install structure instead
of the default <code>usr</code>. With this option the packages created are suitable
for private installation. Keep this option with every command, so that
program knows about the special port:</p>
<pre>
    cygbuild --release 1 --install-usrlocal CMD ...</pre>
</dd>
<dt><strong><a name="l_lzma" class="item"><strong>-l|--lzma</strong></a></strong></dt>

<dd>
<p>Use lzma compression instead of default package compression. This
affects the manual pages and the usr/share/doc/*/ content.</p>
</dd>
<dt><strong><a name="p_passphrase_pass_phrase" class="item"><strong>-p|--passphrase &quot;PASS PHRASE&quot;</strong></a></strong></dt>

<dd>
<p>Signing pass phrase. In multiuser environment, consider security carefully
before using this option.</p>
</dd>
<dt><strong><a name="r_release_release" class="item"><strong>-r|--release RELEASE</strong></a></strong></dt>

<dd>
<p>This option is required option by almost all commands.</p>
<p>Specify build release: 1, 2, 3 etc. If this is word &quot;date&quot;, then derive
build number from <code>date(1)</code> in format YYYYMMDDHHMM</p>
</dd>
<dt><strong><a name="s_sign_signkey" class="item"><strong>-s|--sign SIGNKEY</strong></a></strong></dt>

<dd>
<p>GPG key to use for signing. It is best to use the hexadecimal unique key
id to avoid picking the wrong key from key ring. See <code>gpg --list-keys</code>.</p>
</dd>
<dt><strong><a name="t_test" class="item"><strong>-t|--test</strong></a></strong></dt>

<dd>
<p>Run in test mode. This option is respected when <strong>[install]</strong> command is
run: no actual changes or install is done. This is good way to check that
Makefile doesn't mistakenly install to system directories.</p>
</dd>
<dt><strong><a name="v_verbose" class="item"><strong>-v|--verbose</strong></a></strong></dt>

<dd>
<p>Print more informational messages.</p>
</dd>
<dt><strong><a name="v_version_version" class="item"><strong>-V|--version|--Version</strong></a></strong></dt>

<dd>
<p>Print version number.</p>
</dd>
<dt><strong><a name="x_no_strip" class="item"><strong>-x|--no-strip</strong></a></strong></dt>

<dd>
<p>Do not strip executables or check strip status before command <strong>[package]</strong>.
Use this option if package contains only interpreted files like Perl,
Python or Shell scripts etc.</p>
<p><strong>NOTE:</strong> This options should be avoided and it may be removed. Program is
99% in the cases able to detect if and when strip is needed.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></h1>
<p>
</p>
<h2><a name="preparation_commands">Preparation commands</a></h2>
<dl>
<dt><strong><a name="mkdirs" class="item"><strong>mkdirs</strong></a></strong></dt>

<dd>
<p>Make Cygwin build directories</p>
<pre>
    package-N.N/.build/                    Scratch work area
    package-N.N/.inst/                     Binary package
    package-N.N/.sinst/                    Source package
    package-N.N/CYGWIN-PATCHES/            Control directory</pre>
</dd>
<dt><strong><a name="files" class="item"><strong>files</strong></a></strong></dt>

<dd>
<p>Install default files into <code>package-N.N/CYGWIN-PATCHES/</code>. You have to edit
two mandatory files, <code>README</code> and <code>setup.hint</code>, before running building a
binary package with command <strong>[package]</strong>. Files that include extension
<code>.tmp</code> are examples. These files are only needed if package cannot be
ported directly by using standard <a href="#configure"><code>./configure</code></a> or <code>make install</code> calls.</p>
<pre>
    package.README          Mandatory, edit this
    setup.hint              Mandatory, edit this
    conf.sh.tmp             optional; If there is no ./configure
    build.sh.tmp            optional; If standard &quot;make all&quot;
                                      doesn't do it
    install.sh.tmp          optional; If &quot;make install&quot;
                                      doesn't do it
    install-after.sh.tmp    optional; If &quot;make install&quot;
                                      quite didn't do it right. E.g
                                      moving .inst/etc/* files elsewhere
    postinstall.sh.tmp      optional; Things to do after system
                                      install for binary packages</pre>
<p>If you remove the extension <code>.tmp</code>, the shell scripts are automatically
noticed and used. You can leave the files alone if you do not use them,
because all files ending to <code>.tmp</code> are ignored during
packaging commands <strong>[package]</strong> or <strong>[source-package]</strong>.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="build_commands">Build commands</a></h2>
<dl>
<dt><strong><a name="configure" class="item"><strong>configure</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/configure.sh</code>. If not found,
try <code>package-N.N/configure</code> or <code>package-N.N/buildconf</code> with
predefined Cygwin switches</p>
<p>Before this command, the source files should have been prepared with
command <strong>[shadow]</strong> (which see).</p>
</dd>
<dt><strong><a name="build" class="item"><strong>build</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/build.sh</code>. If not found, then
run command which resembles something like below (cf. <strong>ENVIRONMENT</strong>):</p>
<pre>
    LDFLAGS= CFLAGS=&quot;-O2 -g&quot; make CC=gcc CXX=g++</pre>
</dd>
<dt><strong><a name="make" class="item"><strong>make</strong></a></strong></dt>

<dd>
<p>Synonym for command <strong>[build]</strong>.</p>
</dd>
<dt><strong><a name="dist_real_clean" class="item"><strong>[dist|real]clean</strong></a></strong></dt>

<dd>
<p>Run any <em>make</em> target whose name ends to <code>clean</code>. That is: clean,
distclean, realclean etc.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="install_commands__in_order_of_execution_">Install commands (in order of execution)</a></h2>
<dl>
<dt><strong><a name="strip" class="item"><strong>strip</strong></a></strong></dt>

<dd>
<p>Strip <code>*.exe</code> and <code>*.dll</code> files under <code>package-N.N/.inst/</code></p>
</dd>
<dt><strong><a name="install" class="item"><strong>install</strong></a></strong></dt>

<dd>
<p>Install package to directory <code>package-N.N/.inst/</code>. If use supplied
<code>package-N.N/CYGWIN-PATCHES/install.sh</code> exist, run it instead of normal:</p>
<pre>
    make install</pre>
<p>When porting for the first time, accompany this command with the test
option <strong>-t</strong> so that no harm is done even if Makefile would try to place
files to weird places.</p>
<pre>
    cygbuild --release 1 --test install</pre>
</dd>
<dt><strong><a name="import" class="item"><strong>import</strong></a></strong></dt>

<dd>
<p>Start porting the project. Effectively runs steps <strong>[makedirs]</strong>,
<strong>[files]</strong>, <strong>[configure]</strong>, <strong>[make]</strong>.</p>
</dd>
<dt><strong><a name="check" class="item"><strong>check</strong></a></strong></dt>

<dd>
<p>Run various checks to ensure that the install to directory .inst/ look
good. It is highly recommended that you use this command with verbose
option <strong>--verbose</strong>. Some of the checks include:</p>
<pre>
    - Check that there is no temporary files in install directory
    - Check that package.README looks ok
    - Check if there are info files, but no postinstall script to
      install those info files.
    - Check that all executables also have associated manual pages
      Each program should have manual page, even if it only
      suggests looking elsewhere.
    - etc.</pre>
<p>The directory being checked is <code>./.inst</code> by default, but this
can be changed, e.g. if checking some other package's install
results:</p>
<pre>
    cygbuild --cyginstdir /other/path/.inst --verbose check</pre>
<p>See also description of option <strong>--file</strong> how to check other
developer's binary packaging.</p>
</dd>
<dt><strong><a name="check_deps" class="item"><strong>check-deps</strong></a></strong></dt>

<dd>
<p>Check that all dependencies are listed in <code>package.README</code> and
<code>setup.hint</code>. It is highly recommended that you use this command with
verbose option <strong>--verbose</strong>.</p>
</dd>
<dt><strong><a name="postinstall" class="item"><strong>postinstall</strong></a></strong></dt>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/postinstall.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#postinstall_sh"><code>postinstall.sh</code></a> script if it is
supplied.</p>
</dd>
<dt><strong><a name="preremove" class="item"><strong>preremove</strong></a></strong></dt>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/preremove.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#preremove_sh"><code>preremove.sh</code></a> script if it is
supplied.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="packaging_commands">Packaging commands</a></h2>
<dl>
<dt><strong><a name="mkpatch" class="item"><strong>mkpatch</strong></a></strong></dt>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/diff.sh</code>. If it does not exists,
run diff between original package and current modifications. You must:</p>
<pre>
  1. chdir to directory C&lt;package-N.N/&gt;
  2. Provide original package directly above current run
     directory; that is ../
     (See option -f in case source cannot be found by the program)</pre>
</dd>
<dt><strong><a name="package" class="item"><strong>package</strong></a></strong></dt>

<dd>
<p>Make binary package <code>PACKAGE-VERSION-REL.tar.bz2</code> to directory <code>.sinst/</code>.</p>
</dd>
<dt><strong><a name="package_devel_or_pkgdev" class="item"><strong>package-devel</strong> or <strong>pkgdev</strong></a></strong></dt>

<dd>
<p>For library distributions, this command splits the binary distribution into
three categories:</p>
<pre>
    libPACKAGE-N.N-REL.tar.bz2       *.dll from  usr/
    libPACKAGE-devel-N.N-REL.tar.bz2 all   from  usr/include  usr/lib
    libPACKAGE-doc-N.N-REL.tar.bz2   all   from  usr/doc      usr/man</pre>
<p>The prefix 'lib' is not added in front of PACKAGE if PACKAGE name already
starts with string 'lib'. In order to make a library release, there must be
separate setup hint files for each in directory <code>CYGWIN-PATCHES/</code>.
Program will warn if any of these are missing</p>
<pre>
     setup.hint             for the runnable *.dll
     setup-devel.hint       for the development libraries *.a *.la
     setup-bin.hint         Client files from usr/bin/
     setup-doc.hint         for the documentation</pre>
<p>When command <strong>[publish]</strong> is run, these setup files and the generated bz2
files are copied to appropriate release directories like this:</p>
<pre>
    ROOT   ( $CYGBUILD_PUBLISH_DIR/libpackage/ )
    |
    | setup.hint
    | libPACKAGE-N.N-REL.tar.bz2
    | libPACKAGE-N.N-REL-src.tar.bz2
    |
    +-devel
    | libPACKAGE-devel-N.N-REL.tar.bz2
    | setup.hint (was setup-devel.hint)
    |
    +-bin
    | libPACKAGE-bin-N.N-REL.tar.bz2
    | setup.hint (was setup-bin.hint)
    |
    +-doc
      libPACKAGE-doc-N.N-REL.tar.bz2
      setup.hint (was setup-doc.hint)</pre>
<p>Take for example a sample garbage collection library, whose name is simply
'gc' available at &lt;http://www.hpl.hp.com/personal/Hans_Boehm&gt;. There
are no executable files in. You should not use the name <code>gc</code> to package
this. The problem is the initial unpack directory name <code>gc-6.2.1.6</code> which
is used to generate the package names. The following is not optimal:</p>
<pre>
    $ cd /usr/src/build
      ... make sure contains only source file
    $ tar zxvf gc6.2alpha6.tar.gz
    $ cd gc6.2alpha6  gc-6.2.1.6
    $ cygbuild mkdirs files conf make
      ... edit README and setup.hint
      ... Now make binary package for this library
    $ cygbuild package-devel
    -- Making packages [devel] from /usr/src/build/gc-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc-6.2.1.6-1.tar.bz2
    --   [devel-doc] /usr/src/build/gc-doc-6.2.1.6-1.tar.bz2
    --   [devel-dev] /usr/src/build/gc-devel-6.2.1.6-1.tar.bz2</pre>
<p>It would be better to use the <code>libgc6</code> name, as it is used in Debian,
instead of the homepage's name <code>gc</code>, like this:</p>
<pre>
    ... Unpack as above, but symlink to 'lib' directory
    $ ln -s gc6.2alpha6  libgc6-6.2.1.6
    $ cd libgc6-6.2.1.6
    ... likewise as above for the configure, make etc. and finally ...
    $ cygbuild package-devel
    -- Making packages [devel] from /usr/src/build/libgc6-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc6-6.2.1.6-1.tar.bz2
    --   [devel-doc] /usr/src/build/libgc6-doc-6.2.1.6-1.tar.bz2
    --   [devel-dev] /usr/src/build/libgc6-devel-6.2.1.6-1.tar.bz2
                                    ======</pre>
<p>Notice how all released files now correctly include prefix <code>libgc6</code>.</p>
</dd>
<dt><strong><a name="source_package" class="item"><strong>source-package</strong></a></strong></dt>

<dd>
<p>Make source package <code>PACKAGE-VERSION-REL-src.tar.b2</code> to directory
<code>.sinst/</code>. This command will first run <strong>[clean]</strong> followed by
<strong>[mkpatch]</strong>. This means that all object files and files that can be
generated will be wiped away as if:</p>
<pre>
    make clean distclean</pre>
<p>was called. So, to build binary package after command <strong>source-package</strong>
means that the steps have to be started over. Like this:</p>
<pre>
    cygbuild --release 1 configure make install package</pre>
</dd>
<dt><strong><a name="repackage_all_or_repkg" class="item"><strong>repackage-all</strong> or <strong>repkg</strong></a></strong></dt>

<dd>
<p>Run commands <strong>[configure]</strong>, <strong>[make]</strong>, <strong>[install]</strong>, <strong>[check]</strong>,
<strong>[package]</strong>, <strong>[readmefix]</strong>, <strong>[package]</strong>, <strong>[source-package]</strong> and
<strong>[publish]</strong>. In other words, this command remakes complete Cygwin Net
release. This is the command to start all from the beginning and go to the
finish. This is needed if files <code>package.README</code> or <code>setup.hint</code> is
changed.</p>
</dd>
<dt><strong><a name="repackage_bin_or_repkgbin" class="item"><strong>repackage-bin</strong> or <strong>repkgbin</strong></a></strong></dt>

<dd>
<p>Same as <strong>repackage-all</strong> but stop after binary package has been made. This
command does not proceed to source package or publishing. Handy in
situations where only binary package needs to be remade after corrective
actions to problems found in installation structure:</p>
<pre>
    eyeball C&lt;.inst/&gt; directory, fix whatever is needed and
    run command [repackage-bin]</pre>
<pre>
    [repeat] eyeball ./inst ... until looks good.</pre>
</dd>
<dt><strong><a name="repackage_devel_or_repkgdev" class="item"><strong>repackage-devel</strong> or <strong>repkgdev</strong></a></strong></dt>

<dd>
<p>Like above repackage commands, but for libraries. Run all steps
from beginning to publish.</p>
</dd>
<dt><strong><a name="readmefix" class="item"><strong>readmefix</strong></a></strong></dt>

<dd>
<p>Update files in <code>CYGWIN-PATCHES/*</code> to reflect current package's
mainteiner, version and release numbers. E.g. 'Cygwin port maintained
by' and Copyright statements and any <code>Firstname Lastname</code>, <code>PKG</code>,
<code>VER</code>, <code>REL</code> tags are replaced with the correct values (see
ENVIRONMENT). Remember to supply <strong>--release REL</strong> with this command.</p>
<p>Files with  <em>*.tmp</em> extension are ignored.</p>
</dd>
<dt><strong><a name="finish" class="item"><strong>finish</strong></a></strong></dt>

<dd>
<p>Remove source unpack directory <code>package-N.N/</code>. This command is
dangerous. It might be better to use <code>rm(1)</code> manually.</p>
<p>Really, user should never run this command. It is mostly reserved for
internal build process testing command <strong>[all]</strong>.</p>
</dd>
<dt><strong><a name="publish" class="item"><strong>publish</strong></a></strong></dt>

<dd>
<p>If environment variable <code>CYGBUILD_PUBLISH_BIN</code> is set, the external
program is called with 3 mandatory and 2 optional arguments from options
<strong>--sign</strong> and <strong>--passphrase</strong> if those were available. The shell call
will be in form:</p>
<pre>
    $CYGBUILD_PUBLISH_BIN \
        /directory/where/package-N.N/.sinst/
        &lt;package string&gt;
        &lt;version string&gt;
        &lt;release number&gt;
        [gpg sign id]
        [gpg pass phrase]</pre>
<p>If no <code>CYGBUILD_PUBLISH_BIN</code> exists, source and binary packages are copied
under publish directory <code>$CYGBUILD_PUBLISH_DIR/package/</code>.</p>
<p>It makes sense to run publish command only after commands
<strong>[source-package]</strong> and <strong>[package]</strong>. If command <strong>[package-devel]</strong>
was used, then the published files are copied to separate
subdirectories below <code>$CYGBUILD_PUBLISH_DIR/package/</code>. See command
<strong>[package-devel]</strong> for more information.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="digital_signature_commands">Digital signature commands</a></h2>
<dl>
<dt><strong><a name="sign" class="item"><strong>sign</strong></a></strong></dt>

<dd>
<p>Sign all created packages and the <strong>*.patch</strong> under directory <code>.sinst/</code>.
Commands <strong>[package]</strong> and <strong>[source-package]</strong> can accept sign key option
<strong>--sign</strong> which add the digital signature to archives after they have been
built. Only if you accidentally remove the <code>*.sig</code> files, or if you forgot
to use signing options, you need to separately call this command.</p>
<p>or archive builds.</p>
</dd>
<dt><strong><a name="verify" class="item"><strong>verify</strong></a></strong></dt>

<dd>
<p>Verify all signatures belonging to current package in current directory or
in <code>.sinst/</code>.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="patch_management_commands">Patch management commands</a></h2>
<dl>
<dt><strong><a name="patch" class="item"><strong>patch</strong></a></strong></dt>

<dd>
<p>Apply all <em>*.patch</em> files found recursively under <code>CYGWIN-PATCHES/</code>
to original sources (see command <strong>patch-list</strong>). The applied patches
are recorded in <code>CYGWIN-PATCHES/done-patches.tmp</code> so that they won't
be applied multiple times.</p>
<p>The directories and filenames are best to be prefixed with a
sequential number, like:</p>
<pre>
  0001-Makefile-rewrite-install.patch
  0002-command.c-add-ifdef-Cygwin.patch</pre>
<p>The filenames can include extra <em>strip+N</em> keyword to instruct what is
the <strong>--strip=N</strong> option that should be passed to command patch(1):</p>
<pre>
    &lt;package&gt;-*.strip+N.patch</pre>
<p>An example:</p>
<pre>
    foo-1.2-this-fixes-segfault.strip+2.patch</pre>
<p>NOTE: The use of <em>strip+N</em> argument is usually unnecessary, because
the program heuristics can in most cases determine what is the proper
<strong>--strip</strong> option to <strong>patch(1)</strong> command.</p>
<p>See also command <strong>[unpatch]</strong>.</p>
</dd>
<dt><strong><a name="patch_check_pchk" class="item"><strong>patch-check|pchk</strong></a></strong></dt>

<dd>
<p>Display content of <code>CYGWIN-PATCHES/done-patches.tmp</code> if any and list
filenames from result of command <strong>[mkpatch]</strong>.</p>
</dd>
<dt><strong><a name="patch_list_plist" class="item"><strong>patch-list|plist</strong></a></strong></dt>

<dd>
<p>Display patch list of <code>CYGWIN-PATCHES/</code>. The order is apply order.
Effectively runs command:</p>
<pre>
    find CYGWIN-PATCHES -name &quot;*.patch&quot; | sort</pre>
</dd>
<dt><strong><a name="unpatch" class="item"><strong>unpatch</strong></a></strong></dt>

<dd>
<p>Deapply all *.patch files found using <code>find(1)</code>, followed by <code>sort(1)</code>,
under <code>CYGWIN-PATCHES</code>. On success, the record keeping file
<code>CYGWIN-PATCHES/done-patches.tmp</code> is deleted. The opposite of
<strong>[patch]</strong> command.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="other_commands">Other commands</a></h2>
<dl>
<dt><strong><a name="all" class="item"><strong>all</strong></a></strong></dt>

<dd>
<p>Run all relevant steps: <strong>prep, conf, build, install, strip, package,
source-package, finish</strong>. This command is used to test the integrity of
Cygwin net release. Like this:</p>
<pre>
    root@foo:/usr/src/build# tar -xvf package-N.N-1-src.tar.bz2
        package-N.N-1.sh
        package-N.N-1.patch
        package-N.N-src.tar.gz</pre>
<pre>
    root@foo:/usr/src/build# ./package-N.N-1.sh all</pre>
<p>If the build process breaks, then the fault is in the packaging.
Contact maintainer of <code>package-N.N-1-src.tar.bz2</code> for details.</p>
</dd>
<dt><strong><a name="almostall" class="item">&lt;almostall&gt;</a></strong></dt>

<dd>
<p>Same as command <strong>[all]</strong> but without the <strong>[finish]</strong> step.</p>
</dd>
<dt><strong><a name="cygsrc_b_binary_dir_d_package" class="item"><strong>cygsrc [-b|--binary] [&lt;--dir|-d</strong>] PACKAGE&gt;</a></strong></dt>

<dd>
<p>NOTES: 1) This command must be run in an empty directory for it to
work properly 2) No other command line options are interpreted. This
is stand alone command.</p>
<p>Download both Cygwin source and binary net release package. If option
<strong>--dir</strong> is given, create directory with name <em>PACKAGE</em>, cd to it and
start downloading <em>PACKAGE</em>. If option <strong>--binary</strong> is given, download
only binary package.</p>
<p>This command is primarily used for downloading sources of orphaned
package in order to prepare ITA (intent to adopt) to Cygwin
application mailing list.</p>
<pre>
  1. The content of *-src.tar.bz2 and setup.hint are store
  2. the *.bz2 is unpacked
  3. the CYGWIN-PATCHES is extracted from *.patch
  4. the rest of the patches (excluding CYGWIN-PATCHES) is stored
     to *-rest.patch</pre>
<p>See ENVIRONMENT for changing the download URL location to closer
local Cygwin package mirror site.</p>
</dd>
<dt><strong><a name="prepare" class="item"><strong>prepare</strong></a></strong></dt>

<dd>
<p>This command is not part of the porting commands. It is meant to be used as
a preparation to build Cygwin Net release source package from scratch.
Something like -b option in &quot;source build&quot; commands in <code>.deb</code> and <code>.rpm</code>
packaging managers.</p>
<p>Extract <code>package-VERSION-REL-src.tar.bz2</code> to current directory and apply
patch <code>package-VERSION-REL*.patch</code> and run build command <strong>[makedirs]</strong>.</p>
</dd>
<dt><strong><a name="reshadow" class="item"><strong>reshadow</strong></a></strong></dt>

<dd>
<p>Regenerate all links. Run this command if a) changes are made to the
original source by adding or removing files or b) you've moved the sources
to another directory and the previous links become invalid. Effectively
runs <strong>[rmshadow]</strong> and <strong>[shadow]</strong>. Notice that all compile objects files
are gone too, so you need to recompile everything.</p>
</dd>
<dt><strong><a name="rmshadow" class="item"><strong>rmshadow</strong></a></strong></dt>

<dd>
<p>Remove shadowed source directory recursively. The directory root
is preserved. If you move the original directory to another place, the
shadowed source file links become invalid.</p>
</dd>
<dt><strong><a name="shadow" class="item"><strong>shadow</strong></a></strong></dt>

<dd>
<p>Copy all files from source directory to build directory. The source files
are shadowed by drawing symbolic links to directory <code>./build/build</code>.
The compilation will done there. Usually this command can be replaced with
command <a href="#reshadow"><code>[reshadow]</code></a>.</p>
<p>This command is not usually needed, because the <strong>[configure]</strong> will notice
missing shadow directory and make it as needed.</p>
</dd>
<dt><strong><a name="download" class="item"><strong>download</strong></a></strong></dt>

<dd>
<p>Check upstream site for new versions. External program <em>mywebget.pl</em>
<a href="http://freshmeat.net/projects/perlwebget">http://freshmeat.net/projects/perlwebget</a> is used to do the download. The
configuration file <code>CYGWIN-PATCHES/upstream.perl-webget</code> must contain URL
and additional parameters how to retrieve newer versions. See
<em>mywebget.pl</em>'s manual for more information. Here is an example
configuration file to download and extract new versions of package:</p>
<pre>
  tag1: foo
    <a href="http://prdownloads.sourceforge.net/foo/foo-0.9.1.tar.bz2">http://prdownloads.sourceforge.net/foo/foo-0.9.1.tar.bz2</a> new: x:</pre>
</dd>
<dt><strong><a name="vars" class="item"><strong>vars</strong></a></strong></dt>

<dd>
<p>Print variables and quit. Use this option to see what files and directories
program thinks that it will be using.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This program builds Cygwin binary and source packages. Refer to <em>Cygwin
Package Contributor's Guide</em> at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for more
information about the details of packaging phase. Due to complex nature of
various source packages out there, it is impossible to completely automate
the packaging steps. Some manual work will always be needed. The hairy
ports are those that have very vague and misbehaving <code>Makefile</code> which
install files to all over the system and distribute copies of files with
<code>cp(1)</code> instead of <a href="#install"><code>install(1)</code></a>. Ahem, you as &quot;the porter&quot;, know the
drill and have to use your hands to <code>Makefile</code> mud tar pit. Solid
<code>Makefile</code> experience is therefore a requirement before thinking to port
any packages to Cygwin.</p>
<p>If <code>gpg(1)</code> is installed, the patch, binary and source package can be
cryptographically signed. See options <strong>--sign</strong> and <strong>--passphrase</strong>.</p>
<p>
</p>
<h2><a name="packages_with_no_version_number">Packages with no version number</a></h2>
<p>To port a package which does not have a version number, one has to be
generated out of the blue. Program relies on the fact that the VERSION is
available both in the original package name and in the unpack directory.
The package extensions can be <code>.gz</code>, <code>*.bz2</code> or <code>*.tgz</code>. The recognized
package filename formats include:</p>
<pre>
    package-N[.N]+.tar.gz                Universal packaging format
    package_N[.N]+.orig.tar.gz           Debian source packages</pre>
<p>Like in here:</p>
<pre>
    foo-1.2.tar.gz, foo-0.0.2.tar.bz2, foo-12.0.2.1.tgz</pre>
<p>The package name can consist of many words separated by hyphens:</p>
<pre>
    package-name-long-N[.N]+.tar.gz         Uses hyphens only
    package_name_invalid-N[.N]+.tar.gz      Underscores not allowed</pre>
<p>In case file uses some other naming and numbering scheme, it's a problem.
Similarly if the unpack directory structure does not use universal scheme
<code>package-N.N</code>, it's a problem. Suppose a package unpacks like this:</p>
<pre>
    $ tar zxvf package-beta-latest.tar.gz
        ...
        package-latest
        package-latest/src
        package-latest/doc</pre>
<p>The situation can be coped by making a symbolic link to whatever is
appropriate for the version number. If unsure, pick a YYYYMMDD in case
there is no relevant version that can be used for the package.</p>
<pre>
    $ ln -s package-beta-latest.tar.gz package-YYYYMMDD.tar.gz
    $ ln -s package-latest/ package-YYYYMMDD/</pre>
<p>It is important that you do all your work inside the directory with VERSION
number, not in directory <code>package-latest/</code>.</p>
<pre>
    $ cd package-YYYYMMDD/
    ... now proceed with the porting</pre>
<p>
</p>
<h2><a name="packages_with_non_standard_versioning_schemes">Packages with non-standard versioning schemes</a></h2>
<p>
</p>
<h2><a name="packaging_directly_from_version_control_repositories">Packaging directly from version control repositories</a></h2>
<p>It is easy to make build snapshots by using symlinks with time based
version numbers, like <code>package-20010123</code>, which effectively means
YYYYMMDD. To make a release, it could be done like this:</p>
<pre>
    $ cvs -d :pserver:&lt;remote&gt; co foopackage
    $ date=$(date &quot;+%Y%M%d&quot;)
    $ ln -s foopackage foopackage-$date
    $ cd foopackage-$date
    ... proceed to package this snapshot
    $ cygbuild -r 1 mkdirs files conf make install package source-package</pre>
<p>
</p>
<hr />
<h1><a name="making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></h1>
<p>
</p>
<h2><a name="preliminary_setup">Preliminary setup</a></h2>
<p>1. Create an empty directory, copy original source package there and unpack
it</p>
<pre>
    $ mkdir -p /tmp/build/
    $ cd /tmp/build                   &lt;&lt; go here</pre>
<pre>
    $ rm *
    $ cp /tmp/foo-1.13.tar.gz .
    $ tar zxvf foo-1.13.tar.gz</pre>
<p>2. Test and verify that you can compile package. Run <a href="#configure"><code>./configure</code></a>,
<code>./buildconf</code>, <code>./autogen.sh</code> or <code>./autoconf</code> (if the package includes
only <code>*.in</code> files) as needed. In case of errors, use Google, search
mailing lists, talk to maintainers and find solutions until you can build
package without errors. Modify the files in place as long as it takes to
get package to build. <strong>Do not proceed to other steps until the build
succeeds</strong>.</p>
<pre>
    $ cd foo-1.13/                     &lt;&lt; go here
    $ &lt;run ./config or whatever&gt;
    $ &lt;run make(1). Oops, did not work, edit &amp; fix ...&gt;</pre>
<p>3. [this step is optional] Take a diff of your current changes and move the
diff file to safe place. Knowing that you are secured in case something
goes wrong, greatly reduces your stress when you know you don't have to
start all from scratch. Alternatively use some source control tool right
from the start.</p>
<pre>
    &lt;you're at directory package-N.N/&gt;
    $ cygbuild mkpatch
    $ find .sinst/ -name &quot;*patch&quot;    &lt;&lt; copy this to safe place</pre>
<p>
</p>
<h2><a name="now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></h2>
<p>4. Stay at directory <code>package-N.N/</code> and run few commands, which make
additional Cygwin directories and template files. If this is the first
release, add build release option <strong>-r 1</strong>. Remember to increase build count
if you make more releases of the same package.</p>
<pre>
    $ cd /tmp/build/foo-1.13/
    $ cygbuild -r 1 -v makedirs files
                          ==============</pre>
<p>Command <strong>[makedirs]</strong> created three dot-directories which should be
<code>foo-1.13/{.build,.inst,.sinst}</code>. Command <strong>[files]</strong> wrote few template
files of which two must be modified. The other <code>.tmp</code> files are just
examples they are needed for tricky packages.</p>
<pre>
    $ cd /tmp/build/foo-1.1/CYGWIN-PATCHES/</pre>
<p>Make sure you README and hint files are edited before preceding to building
binary and source packages. If any of the extra scripts are needed, remove
extension <code>.tmp</code> from them to make the scripts active.</p>
<pre>
    foo.README          Modify this file and fill in the '&lt;Headings&gt;:'
    setup.hint          Modify this file</pre>
<pre>
    install.sh.tmp      optional; if 'make install' does not do it
    postinstall.sh.tmp  optional; things to do after installation
    build.sh.tmp        optional; if 'make all' does not do it</pre>
<p>5. Preparations are now ready. It's time to make Cygwin Net release binary
packages. It will appear in directory <code>./.sinst</code>:</p>
<pre>
   $ cd /tmp/build/foo-1.13/
   $ cygbuild -r 1 -v install strip package
                         =====================</pre>
<p>6. Examine carefully the install phase and double check that the created
archive looks correct. Run <code>find(1)</code> to check the directory structure:</p>
<pre>
   $ cd /tmp/build/foo-1.13/
   $ find .inst/ -print
   $ cygbuild -r 1 -v check      &lt;&lt; Run various checks</pre>
<p>Did the manual pages (*.1, *.5, *.8 etc.) got installed correctly under
<code>usr/share/man/manX/</code>? How about <code>*.info</code> files at <code>usr/share/info</code>? Are
the libraries <code>.a</code> and <code>.la</code> or <code>*dll*</code> under <code>usr/lib</code>? Are
executables under <code>usr/bin</code>? If everything is not in order, then you need
to study the package's <code>Makefile</code> and fix it to put files in proper
locations.</p>
<p>Here is shortened listing of a typical library package:</p>
<pre>
    usr/lib/libgc.la
    usr/lib/libgc.a
    usr/man/man3/gc.3
    usr/share/doc/gc-6.1/README.QUICK
    usr/share/doc/gc-6.1/README
    usr/share/doc/gc-6.1/debugging.html
    usr/share/doc/gc-6.1/gc.man
    usr/share/doc/gc-6.1/gcdescr.html
    usr/share/doc/gc-6.1/leak.html
    usr/share/doc/gc-6.1/tree.html
    usr/share/doc/Cygwin/gc-6.1.README</pre>
<p>And here is a shortened listing from a typical executable package:</p>
<pre>
    etc/postinstall/glimpse.sh
    usr/bin/glimpseindex.exe
    usr/bin/glimpse.exe
    usr/bin/glimpseserver.exe
    usr/share/man/man1/glimpse.1
    usr/share/man/man1/glimpseindex.1
    usr/share/man/man1/glimpseserver.1
    usr/share/man/man1/agrep.1
    usr/share/doc/glimpse-4.17.4/CHANGES</pre>
<p>7. Building source packages is much harder, because the program needs to
know more details about configure and build phases. If the default source
packaging command <strong>[source-package]</strong> does not succeed, you probably have
to guide the process slightly by the shell scripts provided under directory
<code>package-N.N/CYGWIN-PATCHES/</code>. Try this first:</p>
<pre>
   &lt;your still at directory package-N.N/&gt;
   $ cygbuild -r 1 -v source-package
                         ==============</pre>
<p>That's it, if all succeeded. At directory up <code>./.sinst</code> you should see two
complete Cygwin Net release shipments: a binary package and a source
package. The RELEASE number is the result of the <strong>-r</strong> option.</p>
<pre>
    foo-1.13-1.tar.bz2
    foo-1.13-1-src.tar.bz2</pre>
<p>
</p>
<h2><a name="contributing_packages">Contributing packages</a></h2>
<p>Refer to &quot;Submitting a package&quot; at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for
full description.</p>
<p>To contribute your package, place them somewhere available and send message
to &lt;<a href="mailto:cygwin-apps@cygwin.com">cygwin-apps@cygwin.com</a>&gt; with following message. The ITP acronym used is
borrowed from Debian and it means &quot;intent to package&quot;:</p>
<pre>
    Subject: [ITP] package-N.N</pre>
<p><strong>Package submittal:</strong> Include contents of <code>setup.hint</code> and the binary
package listing <code>tar jtvf foo-1.13-RELEASE.tar.bz2</code>. Provide complete to a
ftp/http server download links to package files where they can be
downloaded when you submit a contributed package.</p>
<p><strong>Licensing:</strong> As a package maintainer, the licensing responsibility is on
your shoulders. If the upstream package's license if not OSD compatible
(see &lt;http://www.opensource.org/docs/definition_plain.html&gt;) there may be
problems, as the Cygwin glue code (libcygwin.a) is linked in on all
cygwin-targets, thus rendering the compiled result GPL'd (see
<a href="http://www.cygwin.com/licensing.html">http://www.cygwin.com/licensing.html</a> ), unless the license is OSD
approved (see &lt;http://www.opensource.org/licenses/&gt;).</p>
<p>The Cygwin net release is a volunteer effort. If you, the volunteer, do not
feel comfortable with the licensing, then ask for advice on the cygwin-apps
mailing list.</p>
<p><strong>TTL; Time To Live:</strong> If a submitted package has been on the pending
packages list for two months or more, without receiving any votes or no
follow-ups (when requested) it may be dropped from the list. You can
re-submit your package again at a later time, if you choose to do so.
Packages that are already included in major Linux distributions like
Debian, Ubuntu, Redhat, SUSE, Gentoo, Slackware do not need voting
procedure. Mention the link to the distribution page where package is
maintained.</p>
<p><strong>Publishing:</strong> In case you're running Apache web server and world known IP
address, you can publish your files to the world directly. Add this line to
your <code>httpd.conf</code> and make <code>apache(1)</code> read configuration again with
<em>apachectl restart</em>. Check that your connection can see the files with
<code>lynx(1)</code>.</p>
<pre>
    Alias /cygwin /usr/src/cygwin-packages</pre>
<p>As a finishing touch, there is command command <strong>[publish]</strong> which copies
ready source package, binary package and setup.hint to publish area:</p>
<pre>
   &lt;you're still at directory package-N.N/&gt;
   $ cygbuild publish</pre>
<p>
</p>
<hr />
<h1><a name="gpg_examples">GPG EXAMPLES</a></h1>
<p>Let's assume that you have added following build alias command to your
<code>~/.bashrc</code>:</p>
<pre>
    alias cb=&quot;cygbuild --color --sign $GPGKEY&quot;</pre>
<p>You don't want the second alias presented below to be stored in
permanent places, because it contains your GPG identification details.
Copy/paste if to opern terminals as needed.</p>
<pre>
    $ alias bb=&quot;cygbuild -s gpg-key-id -p 'gpg-password'&quot;</pre>
<p>Assuming there already unpacked original package, which has been tested to
build correctly, it's a simple matter of making GPG signed releases.
Perhaps there is something in <code>*.README</code> that needs some correction or
final words. Maybe it had typos. Or <code>setup.hint</code> needed updating. Okay,
run this to make new install which replaced older <code>*.README</code> file:</p>
<pre>
    $ cd foo-1.13/
    $ cb -r 1 -v install check</pre>
<p>Look closely at the results of check command. If anything needs to be
edited or corrected, repeat the command after edit. Verify the
installation:</p>
<pre>
    $ find .inst/ -print | sort</pre>
<p>If all looks good, the signed packages can be made. If you don't have gpg
installed, then substitute plain &quot;b&quot; instead of for &quot;bb&quot; below:</p>
<pre>
    $ bb -r 1 package source-package</pre>
<p>In case there is permanent Internet connection where files can be put to a
publish area (Apache, Ftp), the last step copies packages elsewhere on
local disk:</p>
<pre>
    $ bb 1 publish</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></h1>
<p>All files in <em>CYGWIN-PATCHES/bin</em> are installed as executables into
directory <code>.inst/usr/bin</code>. The location can be changed if any of the
files contains tag <strong>cyginstdir:</strong> to point to new location. An example:</p>
<pre>
    #!/bin/sh
    # cyginstdir: /bin
    ...</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_files">OPTIONAL EXTERNAL FILES</a></h1>
<p>The following list of scripts is alphabetically ordered. The name of
the script indicates when it is run or which command runs it. All
files in <code>CYGWIN-PATCHES/</code> that have suffix <code>.tmp</code> are temporary
templates and not used.</p>
<dl>
<dt><strong><a name="build_options" class="item"><strong>build.options</strong></a></strong></dt>

<dd>
<p>If this file exists, it is sourced to read custom flags and other <em>make(1)</em>
options. The content of the file should be like this. These are the default
values</p>
<pre>
  CYGBUILD_CFLAGS=&quot;-O2 -g&quot;
  CYGBUILD_LDFLAGS=&quot;&quot;          # set to -no-undefined for libraries
  CYGBUILD_MAKEFLAGS=&quot;CC=gcc CXX=g++&quot;</pre>
<p>And they are used in a call to initialize <a href="#make"><code>make(1)</code></a> variables in call like
this:</p>
<pre>
  make CFLAGS=&quot;$CYGBUILD_CFLAGS&quot;   \
       LDFLAGS=&quot;$CYGBUILD_LDFLAGS&quot; \
       $CYGBUILD_MAKEFLAGS</pre>
</dd>
<dt><strong><a name="build_sh" class="item"><strong>build.sh</strong></a></strong></dt>

<dd>
<p>Perhaps simple <code>make all</code> did not compile the package. In that case a custom
<code>CYGWIN-PATCHES/build.sh</code> can be used to give correct options and
commands:</p>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives three arguments: package name, version and
      release number.</pre>
<pre>
    make ... whatever options are needed ...
    make ... perhaps it need other targets as well ...</pre>
</dd>
<dt><strong><a name="configure_env_options" class="item"><strong>configure.env.options</strong></a></strong></dt>

<dd>
<p>If this file exists, it is sourced to read custom environment settings just
before <a href="#configure"><code>./configure</code></a> is being run.</p>
<pre>
    source configure.env.options</pre>
<p>For example to use <strong>ccache gcc</strong> with autotool packages (these with
configure.in, Makefile.am etc) to speed up compilation, there is example
script <code>CYGWIN-PATCHES/compiler.sh.tmp</code> which you can take into use by
removing the <code>.tmp</code> extension. After put this line to the file. Notice
that there is no path in front of <code>compiler.sh</code> because during the
execution the <strong>PATH</strong> variable will include also <code>CYGWIN-PATCHES/</code>.</p>
<pre>
    # Start of CYGWIN-PATCHES/configure.env.options
    CYGBUILD_CC=compiler.sh
    # End of file</pre>
</dd>
<dt><strong><a name="configure_options" class="item"><strong>configure.options</strong></a></strong></dt>

<dd>
<p>If this file exists, all options in this file are appended to the default
Cygwin options set during call to <a href="#configure"><code>./configure</code></a>. Comments may be added to
preceding lines with a hash-mark. An example:</p>
<pre>
    # Include these options during configure:
    --disable-static        # Do not use static libraries
    --enable-tempstore
    --enable-threadsafe
    --with-tcl=/usr</pre>
</dd>
<dt><strong><a name="configure_sh" class="item"><strong>configure.sh</strong></a></strong></dt>

<dd>
<p>In case the package does not include a standard GNU <a href="#configure"><code>./configure</code></a>
script, a custom script <code>CYGWIN-PATCHES/configure.sh</code> can guide all
configure steps. If there is nothing to configure, leave this script
out. For the custom program:</p>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives one argument: absolute path to install root
      directory (that'd be &lt;path&gt;/package-N.N/.inst)</pre>
<p>To start with the custom script, here are the standard Cygwin configure
switches, which you can incorporate:</p>
<pre>
    ./configure
        --target=i686-pc-cygwin
        --srcdir=/usr/src/cygbuild/package/package-N.N
        --prefix=/usr
        --exec-prefix=/usr
        --sysconfdir=/etc
        --libdir=/usr/lib
        --includedir=/usr/include
        --localstatedir=/var
        --libexecdir='${sbindir}'
        --datadir='${prefix}/share'</pre>
</dd>
<dt><strong><a name="diff_options" class="item"><strong>diff.options</strong></a></strong></dt>

<dd>
<p>By default the <a href="#patch"><code>[patch]</code></a> command excludes files that it thinks do not
belong there, but in many case package generate other extra files that
should be excluded too. In this file it is possible to supply extra options
to <code>diff(1)</code> while comparing the original source directory against the
current package directory. The options to diff must be listed one line at a
time. Comments can start with hash-character.</p>
<pre>
    # diff.options -- exclude these files from patch</pre>
<pre>
    --exclude=Makefile.in
    --exclude=Makefile</pre>
<pre>
    # End of file</pre>
<p>There a re couple of options that affect cygbuild itself. If following
option is found, then no automatic guessing what files might have been
auto-generated, is done. This is effectively a pseudo option that
says &quot;turn off internal check&quot;:</p>
<pre>
    --exclude=cygbuild-ignore-autochecks</pre>
<p>To completely suppress all default cygbuild exclude options like those
of <code>*.~, *# *.orig</code> and other files), start the file with use this
line:</p>
<pre>
    --exclude=cygbuild-ignore-all-defaults</pre>
<p><strong>Warning:</strong> due to shell expansions in the program, it is not possible
to use wildcards with short option names, like this:</p>
<pre>
    -x *.tmp</pre>
<p>Please use the long option notation instead:</p>
<pre>
    --exclude=*.tmp</pre>
</dd>
<dt><strong><a name="diff_before_sh" class="item"><strong>diff-before.sh</strong></a></strong></dt>

<dd>
<p>When the original source has been unpacked, it may include files that
prevent taking clean diff. IT could happen that the source package
mistakenly included compiled object files or included dangling symlinks to
the original authors files. This is the chance to &quot;straighten up&quot; things
before diff engages.</p>
</dd>
<dt><strong><a name="diff_sh" class="item"><strong>diff.sh</strong></a></strong></dt>

<dd>
<p>Sometimes the default <strong>[mkpatch]</strong> command - which runs <code>diff(1)</code> with
conservative set of options - is not enough. If package uses many different
file extensions, a custom <code>CYGWIN-PATCHES/diff.sh</code> program can be used to
produce correct differences. The custom program is called with three
arguments:</p>
<pre>
    1. Original package root directory
    2. Modified package root directory
    3. Output file (will be under CYGWIN-PATCHES/.sinst/)</pre>
<p>Program should not change any of these parameters, but only adjust only
<code>diff(1)</code> options. Program must return standard shell status 0 on success
and non-zero on failure.</p>
<p>An example is presented below. For GNU <code>diff(1)</code>, don't forget to add the
final <code>[ &quot;$?&quot; = &quot;1&quot; ]</code> statement, which converts the GNU diff ok exit
status 1 to a standard shell ok exit status 0. GNU diff returns
unconventionally 1 on success and N &gt; 1 on error.</p>
<pre>
    #!/bin/sh
    # CYGWIN-PATCHES/diff.sh -- custom diff</pre>
<pre>
    diff -urN $1 $2             \
            --exclude='.build'  \
            --exclude='.inst'   \
            --exclude='.sinst'  \
            --exclude='*.o'     \
            --exclude='*.a'     \
            --exclude='*.dll'   \
            --exclude='*.exe'   \
            --exclude='*.bak'   \
            --exclude='*.tmp'   \
            --exclude='*~'      \
            --exclude='*#'      \
            --exclude='.#*'     \
            --exclude='.hg'     \
            --exclude='.bzr'    \
            --exclude='.git'    \
            --exclude='CVS'     \
            --exclude='RCS'     \
             ...[your options here]...\
    &gt; $3</pre>
<pre>
    [ &quot;$?&quot; = &quot;1&quot; ]
    # End of file</pre>
</dd>
<dt><strong><a name="install_sh" class="item"><strong>install.sh</strong></a></strong></dt>

<dd>
<p>This script is for binary packaging commands <strong>[package]</strong> and
<strong>[package-devel]</strong>.</p>
<p>If a Makefile (run by <code>make install</code>) includes hard coded paths or uses
<code>cp(1)</code> to copy files, to absolute locations, a custom installation procedure
may be needed. It would also help if the author of the original package were
contacted and suggested that a possible new releases of package would lean
to use <a href="#install"><code>install(1)</code></a> and Makefile variables. Those could be set externally and
controllable manner.</p>
<p>Examine the Makefile and its installation rules and write a script to mimic
same steps. When custom script is called:</p>
<pre>
  1. chdir has been done to source root package-N.N/
  2. it receives one argument: relative root of
     installation directory .inst/</pre>
<p>Be careful and double check the file locations after your custom install.sh
has been run:</p>
<pre>
  $ cd package-N.N/
  $ find .inst/ -print      &lt;&lt; print directory structure</pre>
<p>When the final binary package is installed by some user, it must not
unintentionally overwrite anything that is already in the system.</p>
<p><strong>NOTE:</strong> Instead of this file, it would be much better to gets hands dirty
and modify directly the original <code>Makefile</code>. Even if that meant writing
the whole installation from scratch. Copy install example from template
file <code>CYGWIN-PATCHES/Makefile.tmp</code>.</p>
</dd>
<dt><strong><a name="install_after_sh" class="item"><strong>install-after.sh</strong></a></strong></dt>

<dd>
<p>This script is for binary packages commands <strong>[package]</strong> and
<strong>[package-devel]</strong>. If this script exists, it is called after
cygbuild has run it's standard installation steps.</p>
<p>Sometimes there is no need to write full custom <a href="#install_sh"><code>install.sh</code></a>, but only
combine efforts of packages standard command &quot;make install&quot; with a little
cleanup afterward. For example, suppose that after packages &quot;make install&quot;
the directory structure would look like this (listing has been condensed):</p>
<pre>
    /tmp/build/foo-1.13$ find .inst/ -print
    .inst/
    .inst/usr
    .inst/usr/share/doc
    .inst/usr/share/doc/foo-1.13
    .inst/usr/share/doc/foo-1.13/AUTHORS
    .inst/usr/share/doc/foo-1.13/BUGS
    .inst/usr/share/doc/foo-1.13/INSTALL
    .inst/usr/share/doc/foo-1.13/NEWS
    .inst/usr/share/doc/Cygwin
    .inst/usr/share/doc/Cygwin/foo-1.13.README
    .inst/usr/lib
    .inst/usr/lib/libfoo.la
    .inst/usr/lib/libfoo.a
    .inst/usr/lib/pkgconfig
    .inst/usr/lib/pkgconfig/foo.pc
    .inst/usr/include
    .inst/usr/include/foo
    .inst/usr/include/foo/ne_request.h
    .inst/usr/bin
    .inst/usr/bin/foo-config
    .inst/usr/share
    .inst/usr/share/man/man3
    .inst/usr/share/man/man3/ne_add_request_header.3
    .inst/usr/share/man/man3/ne_addr_destroy.3
    .inst/usr/share/man/man1
    .inst/usr/share/man/man1/foo-config.1
    .inst/usr/share/doc
    .inst/usr/share/doc/foo-1.13
    .inst/usr/share/doc/foo-1.13/html
    .inst/usr/share/doc/foo-1.13/html/apas01.html</pre>
<p>Does everything look good? No. Documentation appears to be installed twice.
In this case it is due to fact that cybuild.sh always runs it's own default
install for files under package's <code>doc/</code> directory. But if run &quot;make
install&quot; also does the same, it's a problem as in this case. The target
directory was just a little different. The documentation must appear in
directory <code>usr/share/doc/</code> and not <code>usr/doc/</code> over, so the
<a href="#install_after_sh"><code>install-after.sh</code></a> script's work is to remove the extra files:</p>
<pre>
    #!/bin/sh</pre>
<pre>
    rm -rf .inst/usr/doc</pre>
<pre>
    # End of file</pre>
</dd>
<dt><strong><a name="install_env_options" class="item"><strong>install.env.options</strong></a></strong></dt>

<dd>
<p>The <strong>[install]</strong> csommand runs series of install phases. After all the
Cygwin documentation is copied to directory <code>/usr/share/doc/foo-1.12</code>, the
standard <code>make install</code> phase is run. If you need to set any environment
variables or arrange other things, do it in this file. It will be called
like</p>
<pre>
    source install.env.options</pre>
<p>If you need exotic 'make install' options, this is the place to configure.
For example, if <code>Makefile</code> does not use <em>DESTDIR</em> option, but a variable
<em>INSTALLROOT</em>, you can add that to 'make install' by defining generic
<code>CYGBUILD_MAKEFLAGS</code> make option. This works, because variables
<code>$instdir</code> and <code>$PREFIX</code> are set in the program and contain the needed
information.</p>
<pre>
    # Start of CYGWIN-PATCHES/install.env.options
    CYGBUILD_MAKEFLAGS=&quot;INSTALLROOT=$instdir$PREFIX&quot;
    # End of file</pre>
</dd>
<dt><strong><a name="install_tar_options" class="item"><strong>install.tar.options</strong></a></strong></dt>

<dd>
<p>The <strong>[install]</strong> command runs series of install phases. In the first, The
Cygwin documentation for package directory <code>/usr/share/doc/foo-1.12</code> is
populated from files in the original package. Those of INSTALL, COPYRIGHT
and README are copied. Then any <code>doc/</code> directory if it is included. The
default rules exclude most common files MANIFEST, *.bak, *.rej etc. and
version control subdirectories.</p>
<p>In this file it is possible to supply extra tar options to exclude more
files not to be included. Perhaps package's <code>doc/</code> directory contains
subdirectories that are targeted to software developers porting the
software etc. The format of file is presented below. Empty lines are
ignored. Comments must be placed in separate lines.</p>
<pre>
    # install.tar.options -- exclude these files from documentation</pre>
<pre>
    --exclude=*RISC*
    --exclude=*README.vms</pre>
<pre>
    #  Include files
    --include=notes.txt</pre>
<pre>
    # End of file</pre>
<p>If following option is defined, the automatic detection of possible
documentation directory is suppressed. Standard options like
<strong>--include=dir</strong> are still obeyed.</p>
<pre>
    --exclude=cygbuild-no-docdir-guess</pre>
<p>If following option is defined, only standard COPYING, TODO etc. files
found from top-level source directory are installed. No other
directories.</p>
<pre>
    --exclude=cygbuild-no-docdir-install</pre>
</dd>
<dt><strong><a name="mandir" class="item"><strong>mandir</strong></a></strong></dt>

<dd>
<p>If this file exists, it should contain only one line: the dorectory
name relative to CYGWIN-PATCHES where the manual pages are stored. An
example (which is also the default location):</p>
<pre>
   $ cat CYGWIN-PATCHES/mandir
   manpages</pre>
<p>This instructs to read manual pages from subdirectory
<code>CYGWIN-PATCHES/manpages/</code> instead of root of <code>CYGWIN-PATCHES/</code>.</p>
</dd>
<dt><strong><a name="manualpage_1_pod" class="item"><strong>manualpage.1.pod</strong></a></strong></dt>

<dd>
<p>In case package does not include manual page or pages for certain
binaries, this file can be used as a template for manual pages. The
format is Perl's plain old documentation (pod) and the file itself is
self explanatory. Just fill in the text and rename the file according
to binaries that are documented. The page number is automatically read
from file name:</p>
<pre>
       X11 programs use section &quot;x&quot;
                                  |
   cp manualpage.1.pod  xprogram.1x.pod
   cp manualpage.1.pod  program.8.pod
      |                 |
      Template file     copy to &lt;program&gt;.&lt;section&gt;.pod</pre>
<p>The typical sections are:</p>
<pre>
   1  Normal binaries
   5  Configuration files
   8  Administrative binaries: /sbin</pre>
<p>Here are some markup help to use in <code>*.pod</code> files. See more
information by running <code>perldoc perlpod</code> or visit
<a href="http://perldoc.perl.org/perlpod.html">http://perldoc.perl.org/perlpod.html</a></p>
<pre>
  B&lt;bold text&gt;
  I&lt;italics&gt;
  C&lt;/some/file/name.here&gt;</pre>
<p>The <em>*.pod</em> files can be put to separate directory
<code>CYGWIN-PATCHES/manpages</code>.</p>
</dd>
<dt><strong><a name="package_bin_sh" class="item"><strong>package-bin.sh</strong></a></strong></dt>

<dd>
<p>If a single standard binary packaging command <strong>[package]</strong> or library
packaging command <strong>[package-devel]</strong> methods are not suitable, it is
possible to write a custom script. There may be need for separating files
into different tar.bz2 files etc. When custom script is called:</p>
<pre>
  1. chdir has been done to installation directory
     CYGWIN-PATCHES/.inst/</pre>
<pre>
  2. script receives 4 arguments:
     PACKAGE VERSION RELEASE TOPDIR</pre>
<p>The <code>TOPDIR</code> is the location where the script should place the <em>tar.bz2</em>
files. It is typically directory above the sources: package-N.N/..</p>
</dd>
<dt><strong><a name="package_source_sh" class="item"><strong>package-source.sh</strong></a></strong></dt>

<dd>
<p>A custom script for making source packages. The call syntax and behavior is
same as <a href="#package_bin_sh"><code>package-bin.sh</code></a> explained above.</p>
</dd>
<dt><strong><a name="postinstall_sh" class="item"><strong>postinstall.sh</strong></a></strong></dt>

<dd>
<p>This file is for command <strong>[package]</strong>, which makes binary packages. The
<a href="#postinstall_sh"><code>postinstall.sh</code></a> is run when user installs Cygwin Net release package in
his system. Here you can clean, move or copy files, check environment and
do other things as needed. Postinstall scripts should assume that <code>PATH</code>
is <em>unset</em>, and all executables should be explicitly specified or the
patch must be set explicitly in script.</p>
</dd>
<dt><strong><a name="prepare_sh" class="item"><strong>prepare.sh</strong></a></strong></dt>

<dd>
<p>A custom script to run when package is prepared. Commands <strong>[all]</strong> and
<strong>[prepare]</strong> run the script. The purpose is to arrange everything to
be ready for the <strong>[configure]</strong> and <strong>[make]</strong> commands.</p>
<p>Normally command <strong>[clean]</strong> would be run along with the standard
preparations. The purpose of the clean is to make sure the source package
did not mistakenly include compiled files. If it did, that would later
prevent 'make' command to do nothing. Doing clean, makes it all pristine.</p>
</dd>
<dt><strong><a name="preremove_sh" class="item"><strong>preremove.sh</strong></a></strong></dt>

<dd>
<p>Copy this file as <code>.inst/etc/preremove/foo.sh</code>. It will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version).</p>
</dd>
<dt><strong><a name="preremove_manifest_lst" class="item"><strong>preremove-manifest.lst</strong></a></strong></dt>

<dd>
<p>If <em>postinstall.sh</em> file copies any default setup files to <code>/etc</code>
directory the absolute path names of files (one or many) must be listed
here. See topic <em>CYGWIN PACKAGE POLICY NOTES::Using preremove.sh and
postinstall.sh for upgrading /etc files</em>.</p>
</dd>
<dt><strong><a name="preremove_manifest_from_lst" class="item"><strong>preremove-manifest-from.lst</strong></a></strong></dt>

<dd>
<p>This file is used by <em>preremove.sh</em>. Contains <strong>list</strong> original
configuration files that are copied to locations mentioned in
<em>preremove-manifest.lst</em> file. A special tag <code>#PKGDOCDIR</code> can be used to
refer to the latest installed directory of
<code>/usr/share/doc/package-version</code>.</p>
<p>An example. Content of <a href="#preremove_manifest_lst"><code>preremove-manifest.lst</code></a> lists the target file that
contains the site wide setup:</p>
<pre>
    /etc/foo.conf</pre>
<p>The previous version of package <code>foo</code> has put documentation in directories:</p>
<pre>
    ...
    /usr/share/doc/foo-1.2
    /usr/share/doc/foo-1.3
    /usr/share/doc/foo-1.4</pre>
<p>so the site wide configuration file could had come from the last
directory. Let's suppose upstream has put the example in:</p>
<pre>
    /usr/share/doc/foo-1.4/examples/foo.conf</pre>
<p>When new version of package is about to be installed by <em>setup.exe</em>, the
<em>preremove.sh</em> script can examine if the system wide setup file(s) pointed
by <a href="#preremove_manifest_lst"><code>preremove-manifest.lst</code></a> hasn't been changed from the package's
upstream examples listed in &lt;preremove-manifest-from.lst&gt; which now can
simply read:</p>
<pre>
    $PKGDOCDIR/examples/foo.conf</pre>
<p>The special tag <code>#PKGDOCDIR</code> is just a shorthand pointer to the latest
documentation directory. If these two files do not differ, the
&lt;preremove.sh&gt; can safely delete <code>/etc/foo.conf</code> and let the
<a href="#postinstall_sh"><code>postinstall.sh</code></a> to install new file from upstream source that is
mentioned in &lt;preremove-manifest-from.lst&gt;. This effectively means:</p>
<pre>
    preremove: if files listed in C&lt;preremove-manifest.lst&gt;
       have not been changed, remove them.</pre>
<pre>
    postinstall: if there are no files that are listed in
        C&lt;preremove-manifest.lst&gt; file then install new upstream files
        pointed by &lt;preremove-manifest-from.lst&gt;</pre>
</dd>
<dt><strong><a name="publish_sh" class="item"><strong>publish.sh</strong></a></strong></dt>

<dd>
<p>A custom script to publish packages.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="managing_a_build_tree">MANAGING A BUILD TREE</a></h1>
<p>
</p>
<h2><a name="how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></h2>
<p>If you intend to port many packages to Cygwin, a good directory structure
helps keeping things organized. Suppose you have 3 packages (foo, bar,
quux) of which 2 have been updated twice (there has been two ported
releases):</p>
<pre>
    ROOT/           ( /usr/src/cygwin-build )
    |
    +--foo/         ( /usr/src/cygwin-build/foo )
    |  +--foo-1.3/
    |  +--foo-1.4/
    |  |
    |  foo-1.3.tar.gz
    |  foo-1.3-1.tar.bz2
    |  foo-1.3-1-src.tar.bz2
    |  |
    |  foo-1.4.tar.gz
    |  foo-1.4-1.tar.bz2
    |  foo-1.4-1-src.tar.bz2
    |
    +--bar/
    |  +--bar-3.12/
    |  +--bar-3.17/
    |  |
    |  bar-3.12.tar.gz
    |  bar-3.12-1.tar.bz2
    |  bar-3.12-1-src.tar.bz2
    |  |
    |  bar-3.17.tar.gz
    |  bar-3.17-1.tar.bz2
    |  bar-3.17-1-src.tar.bz2
    |
    +--quux/
       +--quux-2.2/
       |
       quux-2.2.tar.gz
       quux-2.2-1.tar.bz2
       quux-2.2-1-src.tar.bz2</pre>
<p>At first sight this may look complex, but with this structure you can
manage several packages easily. For each package, reserve a separate
directory where you do your work: <code>foo/</code>, <code>bar/</code>, <code>quux/</code> etc. Download
original packages to these directories and unpack the sources. Let's examine
package <code>foo</code></p>
<pre>
    $ cd /usr/src/cygwin-build/foo
    $ wget &lt;URL&gt;/foo-1.4.tar.gz</pre>
<p>After unpack, you should see a clean directory name:</p>
<pre>
    $ tar zxvf foo-1.4.tar.gz</pre>
<pre>
    foo-1.4/</pre>
<p>Sometimes the packages unpacks to an uncommon directory:</p>
<pre>
    foo1.4b/</pre>
<p>Use previously recommended symlink approach to convert the name into more
standard form. Here the 'b' is minor release '2':</p>
<pre>
    $ ln -s foo1.4b/ foo-1.4.2/</pre>
<p>There isn't much to do after that. You do your builds in the unpack
directories as usual. Supposing this is &quot;standard&quot; looking GNU package
which includes a <a href="#configure"><code>./configure</code></a>, making a Net release should be as simple
as running:</p>
<pre>
    $ cd foo-1.4/
    $ cygbuild files</pre>
<pre>
    ...  Now edit files in CYGWIN-PATCHES/</pre>
<pre>
    $ cygbuild configure make install</pre>
<pre>
    ... Verify install results</pre>
<pre>
    $ find .inst/</pre>
<pre>
    ... If all look okay, make binary and source Net releases</pre>
<pre>
    $ cygbuild -r 1 install package readmefix install package source-package</pre>
<p>With these commands, Cygwin Net release packages are copied one directory
up to the same place where the original compresses source kit is:</p>
<pre>
    /usr/src/cygwin-build/foo/foo-1.4-1.tar.bz2
    /usr/src/cygwin-build/foo/foo-1.4-1-src.tar.bz2</pre>
<p>If you have a web server that can serve the package, copy the files to
publish area with command:</p>
<pre>
    foo-1.4$ cygbuild publish</pre>
<p>
</p>
<h2><a name="rebuilding_packages">Rebuilding packages</a></h2>
<p>NOTE: This section is highly experimental and the program has not yet been
tested well. (FIXME)</p>
<p>As Cygwin is improved, the main library file <code>cygwin1.dll</code> may change and
periodically all packages must be rebuilt so that they link to the latest
function calls. In this case you have to rebuild every package you
maintain. Instead of going to every directory and typing the relevant
&quot;cygbuild clean conf make install ..&quot;, there is a helper script that
automates the task. If you use the standard build layout as described in
previous topic, you can use rebuild script to do the steps. Is is also a
good chance to verify that the package build process is repeatable:</p>
<pre>
    $ cygbuild-rebuild.sh -d /usr/src/cygwin-build -i 1 2&gt;&amp;1 | tee build.log
                           |                       |
                           |                       increase releases by 1
                           |
                           directory where to start recursive build</pre>
<p>If something goes wrong, you have to manually fix the package. Do not run
the rebuild script again until you have fixed the build process for a
broken package.</p>
<p>
</p>
<hr />
<h1><a name="library_usage">LIBRARY USAGE</a></h1>
<p>In addition to <em>cygbuild</em> being a builder program, it can be used as a
library that can be sourced to any bash program. This makes it possible to
selectively use functions in it. The library feature is enabled by setting
variable <code>CYGBUILD_LIB</code> before <code>source</code> command. When invoked this way,
the <em>cygbuild's</em> <code>Main()</code> function in not invoked and options or
commands are bypassed.</p>
<p><strong>WARNING:</strong> All the functions are name space clean and contain prefix
<strong>Cygbuild*</strong>, but many global variables are defined that do not
include the prefix: <code>$instdir</code>, <code>$builddir</code> etc.</p>
<p>To get access to full power of the functions, these steps are needed:</p>
<pre>
    #!/bin/sh</pre>
<pre>
    CYGBUILD=$(which cygbuild)</pre>
<pre>
    #   Load &quot;as library&quot;</pre>
<pre>
    CYGBUILD_LIB=1 source $CYGBUILD</pre>
<pre>
    #   Provided that the current directory's PWD is inside
    #   some/path/foo-1.13. If not, then please skip this part
    #   completely.</pre>
<pre>
    local tdir=$(pwd)
    local -a array=( $(CygbuildSrcDirLocation $tdir) )
    local top=${array[0]}
    local src=${array[1]}</pre>
<pre>
    CygbuildDefineGlobalMain    \
        &quot;$top&quot;                  \
        &quot;$src&quot;                  \
        &quot;$RELEASE&quot;              \</pre>
<pre>
    #   Now any function can be called. Like installing documentation</pre>
<pre>
    CygbuildInstallPackageDocs
    CygbuildInstallCygwinPart</pre>
<pre>
    #   End of example</pre>
<p>
</p>
<hr />
<h1><a name="cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></h1>
<p>
</p>
<h2><a name="using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></h2>
<p>The /etc directory is meant for configuration files for programs. The first
installation typically copies the package's default setup file there but
subsequent installations won't overwrite existing files in order to
preserve user's modifications. If new version of the package includes new
features, those are not found from the &quot;old&quot; /etc configuration files.</p>
<p>Let's suppose user has not yet modified system wide configuration file
<code>/etc/foo.conf</code> and package includes newer one in
<code>/usr/share/doc/foo-1.2/foo.conf.example</code>. In this case the installation
should copy the new example file over <code>/etc/foo.conf</code> to reflect possible
new features in the program.</p>
<p>The trick is to include a <em>preremove.sh</em> script in the Cygwin Net Release
binary package. A file named <code>/etc/preremove/foo.sh</code> will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version), so in that script, if
<code>/etc/foo.conf</code> exists and is identical to
<code>/usr/share/doc/foo.conf.example</code>, the <em>preremove.sh</em> should delete it
and let <em>postinstall.sh</em> install new one. If the <code>/etc/foo.conf</code> is
modified, it must be left alone.</p>
<p>Also, it is a good idea to have a file <code>/etc/preremove/foo-manifest.lst</code>,
which lists every file that was created by the <em>postinstall.sh</em> script,
and which will be removed on <em>preremove.sh</em> if untouched by the user.
Someday, <code>cygcheck -c</code> might parse the manifest lists to help diagnose if
postinstall has not completed.</p>
<p>
</p>
<h2><a name="music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></h2>
<p>It is allowed to include any music related code if MP3 related code is not
compiled in (cf.
 <a href="http://permalink.gmane.org/gmane.os.cygwin.applications/11360">http://permalink.gmane.org/gmane.os.cygwin.applications/11360</a> )</p>
<p>As long as Cygwin is released on US based server, the general rules
are that it is permissible to include and not include in Cygwin are
basically the same as for the Fedora project
&lt;http://fedoraproject.org/wiki/ForbiddenItems&gt;:</p>
<pre>
  * If it is proprietary, it cannot be included in Cygwin.
  * If it is legally encumbered, it cannot be included in Cygwin.
  * If it violates US Federal law, it cannot be included in Cygwin.</pre>
<p>This is different from SUSE and Debian. SUSE is located in another
country may even pay royalties. Debian has a different legal point of
view than Red Hat
(cf. &lt;http://lists.debian.org/debian-legal/2005/07/msg00081.html&gt;). Due to
Cygwin's presence on a Red Hat server, the project is bound to Red Hat
rules.</p>
<p>
</p>
<hr />
<h1><a name="troubleshooting">TROUBLESHOOTING</a></h1>
<p>
</p>
<h2><a name="porting_and_python_os_rename">Porting and Python os.rename</a></h2>
<p>If python application contains calls to <em>os.rename(from, to)</em> or
<em>osutils.rename(from, to)</em>, these will cause unlock race
condition under Cygwin.</p>
<pre>
  OSError: [Errno 13] Permission denied</pre>
<p>Please contact the upstream to negotiate how to solve this. One possible
solution is to rewrite all calls to:</p>
<pre>
    import os, shutil</pre>
<pre>
    def saferename(a, b):
        shutil.copy2(a, b)
        os.unlink(a)</pre>
<p>
</p>
<h2><a name="general_errors">General errors</a></h2>
<p>Make always sure that you work inside well formed source directory
<code>package-VERSION/</code>, like <code>foo-1.13/</code>. If you issue command anywhere
else, the program does not know where it is.</p>
<p>
</p>
<h2><a name="problem_with_command__all_">Problem with command [all]</a></h2>
<p>If you get an error, make sure that you have a clean build directory.
Nothing else other than:</p>
<pre>
    1. a source file
    2. a possible patch to make package work under Cygwin</pre>
<p>The <strong>[all]</strong> is special and it should not be run only for testing already
packages Cygwin Net Releases. It unpacks and patches the source package. If
any other commands are run patch may be tried to apply second time which
naturally fails and script execution stops. Something like</p>
<pre>
    The next patch would create the file ...
    which already exists!  Skipping patch.
    1 out of 1 hunk ignored -- saving rejects to file ...
    [FATAL] status is 1.</pre>
<p>Start all from fresh. Remove unpack directory <code>rm -rf package-N.N/</code> and
repeat command <strong>[all]</strong>.</p>
<p>
</p>
<h2><a name="command__check__cannot_find_files">Command [check] cannot find files</a></h2>
<p>The full error reads something like this:</p>
<pre>
    cygbuild.pl.CygcheckDepsCheckMain: Nothing to do, no *.exe *.dll found in /usr/src/build/package/package-5.07/.inst</pre>
<p>Command <strong>[check]</strong> was ran, but commands <strong>[conf]</strong> <strong>[make]</strong> and
<strong>[install]</strong> were not. The <strong>[install]</strong> phase copies files under <code>.inst/</code>
directory where the <strong>[check]</strong> command expects them.</p>
<p>
</p>
<h2><a name="problem_with_command__install_">Problem with command [install]</a></h2>
<p>Following error is displayed:</p>
<pre>
    $ cygbuild -v -r 1 package</pre>
<pre>
    [ERROR] no package-0.5/.inst/usr/share/doc/Cygwin.
    Did forget to run 'files' before 'install'?</pre>
<p>The check did not find anything inside
<code>.inst/usr/share/doc/Cygwin</code> which is mandatory directory for Cygwin
binary packages. Check that directory <code>package-N.N/CYGWIN-PATCHES/</code>
includes files <code>package.README</code> and <code>setup.hint</code>. These files can be
initially created with command <strong>[files]</strong>.</p>
<p>
</p>
<h2><a name="command__package__displays_warnings">Command [package] displays warnings</a></h2>
<p>Following warning while making a binary package is displayed:</p>
<pre>
    -- Wait, reading and preparing variables based on current directory
    -- Hm, no *.exe or *.dll files, skipping strip.
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:1:&lt;PKG&gt;
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:24:  unpack &lt;PKG&gt;-VER-REL-src.tar.bz2</pre>
<p>The warning means, that file <code>CYGWIN-PATCHES/package.README</code> looked
like a template. Edit <code>package.README</code> file and leave all &lt;PKG&gt;, &lt;VER&gt;
and &lt;REL&gt; tags alone. Then run command <strong>[readmefix]</strong> which will substitute
proper values for these tags.</p>
<p>
</p>
<h2><a name="while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></h2>
<p>Program uses predefined set of ignore rules to exclude binary files
from the difference comparison. There is always a possibility that the
package you compiled generated binary files that are unknown. In those
cases, examine the diff output carefully hinted by message:</p>
<pre>
    [ERROR] Making a patch failed, check /usr/src/foo-N.N/.sinst/foo-*.patch</pre>
<p>Run following command to determine the problematic files in the
<code>diff(1)</code> listing:</p>
<pre>
    $ egrep -n -i 'files.*differ' /usr/src/foo-N.N/.sinst/foo-*.patch</pre>
<p>Add problematic file patterns file <em class="file">CYGWIN-PATCHES/diff.options</em> or
in difficult cases write custom <code>CYGWIN-PATCHES/diff.sh</code> script. See
section &quot;Optional external scripts&quot; for more information.</p>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<p>Default values for command <strong>[install]</strong>:</p>
<pre>
    CYGBUILD_INSTALL=/usr/bin/install
    CYGBUILD_INSTALL_DATA=&quot;-m 644&quot;
    CYGBUILD_INSTALL_BIN=&quot;-m 755&quot;</pre>
<p>Default values for command <strong>[publish]</strong>:</p>
<pre>
    CYGBUILD_PUBLISH_DIR=/usr/src/cygwin-packages
    CYGBUILD_PUBLISH_BIN=</pre>
<p>Default values for command <strong>[readmefix]</strong> are below. The lines below mean
that if <code>CYGBUILD_FULLNAME</code> is not set, the <code>NAME</code> is tried, and last Debian
<code>DEBFULLNAME</code> variable. See also option <strong>--email</strong>.</p>
<pre>
    CYGBUILD_FULLNAME || NAME
    CYGBUILD_EMAIL    || EMAIL</pre>
<p>Default values for command <strong>[cygsrc]</strong>. The value must point to
URL directory where Cygwin Net Release setup.ini file resides.</p>
<pre>
    CYGBUILD_SRCPKG_URL=<a href="http://mirror.switch.ch/ftp/mirror/cygwin">http://mirror.switch.ch/ftp/mirror/cygwin</a></pre>
<p>Temporary values can be given from /bin/bash prompt like this:</p>
<pre>
    bash$ EMAIL=me@example.org cygbuild [options] -r RELEASE &lt;commands&gt;</pre>
<p>
</p>
<hr />
<h1><a name="files">FILES</a></h1>
<p>Temporary files are created to <code>/tmp/cygbuild.tmp.*</code>. They are removed at
the end of program.</p>
<p>Command <strong>[files]</strong> creates template files under <code>./CYGWIN-PATCHES</code>.
Default templates are located in directory
<code>/usr/share/cygbuild/template</code>. Developer's own templates can
be placed in directory <code>/etc/cygbuild/template</code>. These overwrite those in
<code>/usr/share/cygbuild/template</code>.</p>
<p>
</p>
<hr />
<h1><a name="standards">STANDARDS</a></h1>
<p>Cygwin Package Contributor's Guide' at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> .
Remember to compile libraries using <strong>-Wl,--enable-auto-image-base</strong>
Cf. 2005-12-19 &lt;http://cygwin.com/ml/cygwin-apps/2005-12/msg00101.html&gt;.</p>
<p>A generic Bourne Shell build script can be found at page
<a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> and also available at</p>
<pre>
  cvs -d :pserver:anoncvs@sources.redhat.com:/cvs/cygwin-apps checkout packaging/templates</pre>
<p>Consult list of packages before intent to port [ITP]: See file
/etc/setup/installed.db or oage &lt;http://cygwin.com/packages/&gt;.</p>
<p>File system Hierarchy Standard at &lt;http://www.pathname.com/fhs/&gt;</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>
</p>
<h2><a name="commands_must_be_ordered">Commands must be ordered</a></h2>
<p>The application does not check the sanity of the command line
arguments. For example running commands in wrong order. It makes no
sense trying to make a binary <em>package</em> before the package has been
built or installed.</p>
<pre>
   cygbuild -r 1 package conf make install</pre>
<p>The commands are always executed in listed order.</p>
<p>
</p>
<h2><a name="other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></h2>
<p>This porting tool only handles <code>*.tar.gz</code>, <code>*.tar.bz2</code>,
<code>*.tar.lzma</code> archives. To port e.g. a <code>*.zip</code> archive, you need to
manually convert it to recognized format:</p>
<pre>
    unzip foo-N.N.zip
    tar -cvf foo-1.1.tar.gz foo-N.N/
    ... Now proceed normally
    cd foo-N.N/
    cygbuild -r 1 mkdirs files conf make install</pre>
<p>
</p>
<h2><a name="reporting_bugs">Reporting bugs</a></h2>
<p>If you ran into a bug, run script in debug mode and send complete
output listing to the maintainer. Provide also an URL link to the
source package that you tried to build.</p>
<pre>
    $ echo <a href="http://example.com/source">http://example.com/source</a>      &gt;  ~/tmp/error.log
    $ pwd; ls -la . ..                    &gt;&gt; ~/tmp/error.log
    $ bash -x cygbuild [options] CMD ...  &gt;&gt; ~/tmp/error.log 2&gt;&amp;1</pre>
<p>
</p>
<h2><a name="slow_program_startup">Slow program startup</a></h2>
<p>You may notice that the startup is a little slow. This is due to way
the program determining what many global variables need to be
available at runtime. The method of checking environment is not
particularly efficient (due to bash-scripting limitations in general).
E.g. same checks of version and release numbers are called multiple
times.</p>
<p>
</p>
<hr />
<h1><a name="miscellaneous">MISCELLANEOUS</a></h1>
<p>
</p>
<h2><a name="makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></h2>
<p>To compile libraries for Cygwin, the <code>LDFLAGS</code> should include option
<code>-no-undefined</code>. If there is <code>Makefile(.in|.am)</code>, after patching
them manually, you can regenerate the Makefiles with</p>
<pre>
    $ autoreconf --install --force --verbose</pre>
<p>
</p>
<h2><a name="yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></h2>
<p>Sometimes the <code>*.y</code> file won't compile. See thread &quot;ftpcmd.y --
syntax error&quot; at
&lt;http://lists.gnu.org/archive/html/help-bison/2004-04/msg00015.html&gt;.</p>
<pre>
    bison -y ftpcmd.y
    ftpcmd.y:185.17: syntax error, unexpected &quot;=&quot;</pre>
<pre>
    ...There are occurrences of &quot;&lt;tab&gt;=&lt;tab&gt;{&quot; in ftpcmd.y (in the
    wu-ftpd 2.6.2 source release). Changing all of these to &quot;&lt;tab&gt;{&quot;
    fixes the problem -- and doesn't cause problems for Berkeley yacc,
    or for earlier versions of bison.</pre>
<p>
</p>
<h2><a name="cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></h2>
<p>If program X's <a href="#postinstall"><code>postinstall</code></a> is doing a <code>cp</code>, it does not preserve the ACL
permissions. The <a href="#postinstall"><code>postinstall</code></a> script must be accompanied with <code>touch(1)</code>
to create the new file before copying unto it or a call to <code>chmod</code> to set
reasonable permissions after the copying. If that's not done, the user may
end up having unreadable files. NOTE: <code>cp -p</code> will not work, but <code>install
-m</code> would.
(Cf. &lt;http://cygwin.com/ml/cygwin-apps/2005-01/msg00148.html&gt;).</p>
<p>
</p>
<h2><a name="use_of_hard_links">Use of hard links</a></h2>
<p>Some ported packages may rely on hard links. Those are efficient only
under NTFS and not FAT. Please include note to &lt;package&gt;.README that
the utility may not be best under FAT file systems.</p>
<p>
</p>
<h2><a name="setup_hint_should_list_all_dependencies">setup.hint should list all dependencies</a></h2>
<p>The <em>requires:</em> line is not only an indication of what to pull in,
but also what the package actually uses. These dependences are also
used to find the order of postinstall scripts (so, if package has any
postinstall scripts with <code>#!/bin/sh</code>, the scripts may not work
because the bash postinstall script was not run). So include all
direct dependences in the <em>requires:</em> line, even if they are in
<strong>Base</strong> category.
(Cf. &lt;http://cygwin.com/ml/cygwin-apps/2008-03/msg00070.html&gt;).</p>
<p>
</p>
<hr />
<h1><a name="availability">AVAILABILITY</a></h1>
<p><a href="http://freshmeat.net/projects/cygbuild">http://freshmeat.net/projects/cygbuild</a></p>
<p>
</p>
<hr />
<h1><a name="osnames">OSNAMES</a></h1>
<p>Cygwin</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><code>cygport(1)</code>
<code>gpg(1)</code></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Copyright (C) 2003-2009 Jari Aalto. This program is free software; you
can redistribute and/or modify program under the terms of Gnu General
Public license v2 or, at your option, any later version.</p>

</body>

</html>
